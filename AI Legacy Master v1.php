{source}
<?php
use Joomla\CMS\Uri\Uri;

// Canonical tag (ensures correct indexing)
$canonicalUrl = Uri::getInstance()->toString();
echo '<link rel="canonical" href="' . htmlspecialchars($canonicalUrl) . '" />' . "\n";

// Hreflang setup for generic English + fallback
$pathWithQuery = Uri::getInstance()->toString(['path', 'query']);
$href = 'https://lottoexpert.net' . $pathWithQuery;

echo '<link rel="alternate" hreflang="en" href="' . $href . '" />' . "\n";
echo '<link rel="alternate" hreflang="x-default" href="' . $href . '" />' . "\n";


// PREVENT UNAUTHORIZED ACCESS ASAP
defined('_JEXEC') or die('Restricted access');

// Include Joomla authentication early
include '../joomla-auth.php';

// Define Joomla constants if not already set
if (!defined('JPATH_BASE')) {
    define('JPATH_BASE', realpath(dirname(__FILE__) . '/../..'));
}
if (!defined('_JEXEC')) {
    define('_JEXEC', 1);
}

// Load Joomla Framework
require_once JPATH_BASE . '/includes/defines.php';
require_once JPATH_BASE . '/includes/framework.php';

/**
 * Single source of truth for the Lottery Game ID.
 * Change this one value, and all lookups will use it.
 */
// --- DETERMINE GAME ID ------------------------------
// Accept any alphanumeric `game_id` from URL (e.g. MA2, MAA, 132); default to '101'
$rawId = isset($_GET['game_id']) ? trim($_GET['game_id']) : '';
// Validate: only letters and digits allowed
if (preg_match('/^[A-Za-z0-9]+$/', $rawId)) {
    $gameId = $rawId;
} else {
    $gameId = '101';
}

$app = JFactory::getApplication('site');
$db  = JFactory::getDbo(); // ? Unified DB access

// Get the current user BEFORE processing the save request
$currUser   = JFactory::getUser();
$userGroups = $currUser->groups ?? [];

// Explicit fallback group if no specific rule exists for a game
$defaultGroups = [14];

// Explicit allowed groups per game (no merging, no auto-matching)
$gameGroups = [
    '101' => [1, 2, 10, 12, 13, 14],
    '113' => [1, 2, 10, 12, 13, 14],
    '801' => [1, 2, 10, 12, 13, 14],
    // Add more as needed…
];

// Pick the right list of allowed groups
if (isset($gameGroups[$gameId])) {
    $allowedGroups = $gameGroups[$gameId];
} else {
    $allowedGroups = $defaultGroups;
}

// Guest check: only allow if group 1 is in allowed groups
if ($currUser->guest && in_array(1, $allowedGroups)) {
    $userIsInAllowedGroup = true;
} else {
    $userIsInAllowedGroup = !empty(array_intersect($allowedGroups, $userGroups));
}

/**
 * SAVE ENTITLEMENT GATE
 * Enthusiast (group 10) can save ONLY on Powerball (gameId 101).
 * Members (group 14) can save anywhere they are allowed to run analysis.
 */
$enthusiastGroupId = 10;   // Enthusiast plan
$powerballGameId   = '101';

$isEnthusiast = in_array($enthusiastGroupId, $userGroups, true);

// Allow save only if analysis is allowed AND (not enthusiast OR Powerball)
$userCanSave = $userIsInAllowedGroup && (!$isEnthusiast || (string)$gameId === $powerballGameId);

/**
 * ------------------------------------------
 * SKAI Gate: Powerball Enthusiast Daily Cap
 * ------------------------------------------
 * Rules (as requested):
 *  - Guests: cannot run (must register as free "Lottery Enthusiast")
 *  - Lottery Enthusiast (group 10): Powerball only + 1 run/day
 *  - Paid/allowed groups: run as normal (no cap applied here)
 *
 * Endpoint: current URL + ?le_gate=1 (POST + CSRF token required)
 */
$enthusiastDailyCap = 1; // 1 run/day for group 10 (Powerball only)

function leIpHash(): string
{
    $ip = $_SERVER['REMOTE_ADDR'] ?? '';
    $ua = $_SERVER['HTTP_USER_AGENT'] ?? '';
    $salt = 'le_salt_' . date('Ym'); // rotates monthly
    return hash('sha256', $ip . '|' . $ua . '|' . $salt);
}

function leEnsureRunGateTable($db): void
{
    // Defensive: ensure we have a Joomla DB driver
    if (!is_object($db) || !method_exists($db, 'getPrefix') || !method_exists($db, 'quoteName')) {
        throw new \RuntimeException('DB driver not available for run-gate table creation.');
    }

    // Most reliable in mixed bootstraps: explicitly build the physical table name
    $prefix    = (string) $db->getPrefix();
    $tableName = $prefix . 'le_run_gate';

    // Hard guard: never allow empty table names
    if (trim($tableName) === '' || $tableName === $prefix) {
        throw new \RuntimeException('Resolved run-gate table name is empty.');
    }

    $sql = "
        CREATE TABLE IF NOT EXISTS " . $db->quoteName($tableName) . " (
            " . $db->quoteName('id') . " INT UNSIGNED NOT NULL AUTO_INCREMENT,
            " . $db->quoteName('run_date') . " DATE NOT NULL,
            " . $db->quoteName('game_id') . " VARCHAR(32) NOT NULL,
            " . $db->quoteName('user_id') . " INT UNSIGNED NOT NULL DEFAULT 0,
            " . $db->quoteName('ip_hash') . " CHAR(64) NOT NULL DEFAULT '',
            " . $db->quoteName('runs') . " INT UNSIGNED NOT NULL DEFAULT 0,
            " . $db->quoteName('updated_at') . " DATETIME NOT NULL,
            PRIMARY KEY (" . $db->quoteName('id') . "),
            UNIQUE KEY " . $db->quoteName('uniq_day_game_user_ip') . " (
                " . $db->quoteName('run_date') . ",
                " . $db->quoteName('game_id') . ",
                " . $db->quoteName('user_id') . ",
                " . $db->quoteName('ip_hash') . "
            )
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    ";

    $db->setQuery($sql);
    $db->execute();
}

function leGetRunsToday($db, string $gameId, int $userId, string $ipHash): int
{
    // Resolve the real table name first; then quote it (prevents empty/incorrect identifiers)
    $table = (string) $db->getPrefix() . 'le_run_gate';

    $q = $db->getQuery(true)
        ->select($db->quoteName('runs'))
        ->from($db->quoteName($table))
        ->where($db->quoteName('run_date') . ' = CURDATE()')
        ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
        ->where($db->quoteName('user_id') . ' = ' . (int) $userId)
        ->where($db->quoteName('ip_hash') . ' = ' . $db->quote($ipHash));

    $db->setQuery($q);
    $val = $db->loadResult();

    return (int) ($val ?? 0);
}

function leBumpRunsToday($db, string $gameId, int $userId, string $ipHash): void
{
    // Resolve the real table name first; then quote it (prevents empty/incorrect identifiers)
    $table = (string) $db->getPrefix() . 'le_run_gate';

    $now = date('Y-m-d H:i:s');

    $insert = $db->getQuery(true)
        ->insert($db->quoteName($table))
        ->columns([
            $db->quoteName('run_date'),
            $db->quoteName('game_id'),
            $db->quoteName('user_id'),
            $db->quoteName('ip_hash'),
            $db->quoteName('runs'),
            $db->quoteName('updated_at'),
        ])
        ->values(
            'CURDATE()' . ', ' .
            $db->quote($gameId) . ', ' .
            (int) $userId . ', ' .
            $db->quote($ipHash) . ', ' .
            '1, ' .
            $db->quote($now)
        );

    try {
        $db->setQuery($insert);
        $db->execute();
    } catch (\Throwable $e) {
        $update = $db->getQuery(true)
            ->update($db->quoteName($table))
            ->set($db->quoteName('runs') . ' = ' . $db->quoteName('runs') . ' + 1')
            ->set($db->quoteName('updated_at') . ' = ' . $db->quote($now))
            ->where($db->quoteName('run_date') . ' = CURDATE()')
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('user_id') . ' = ' . (int) $userId)
            ->where($db->quoteName('ip_hash') . ' = ' . $db->quote($ipHash));

        $db->setQuery($update);
        $db->execute();
    }
}


if (isset($_GET['le_gate']) && (string) $_GET['le_gate'] === '1') {
    header('Content-Type: application/json; charset=utf-8');

    if (!JSession::checkToken('post')) {
        echo json_encode([
            'ok' => false,
            'code' => 'CSRF',
            'message' => 'Session expired. Please refresh and try again.'
        ]);
        exit;
    }

    // leEnsureRunGateTable($db); // Disabled in production: table is created once via DB migration/manual SQL.

    $isGuest = (bool) $currUser->guest;
    $ipHash  = leIpHash();

    // Guests must register (free Enthusiast) before running.
    if ($isGuest) {
        echo json_encode([
            'ok' => false,
            'code' => 'GUEST_REGISTER',
            'message' => 'Create a free Lottery Enthusiast account to run Powerball analysis and save your predictions.'
        ]);
        exit;
    }

    // Must at least be in allowed groups to run anything
    if (!$userIsInAllowedGroup) {
        echo json_encode([
            'ok' => false,
            'code' => 'NOT_ALLOWED',
            'message' => 'Create a free Lottery Enthusiast account to run Powerball analysis and save your predictions.'
        ]);
        exit;
    }

    // Enthusiast: Powerball only + 1 run/day
    if ($isEnthusiast) {
        if ((string) $gameId !== (string) $powerballGameId) {
            echo json_encode([
                'ok' => false,
                'code' => 'ENTH_PB_ONLY',
                'message' => 'Lottery Enthusiast access is available for Powerball. Upgrade for full access to all lotteries.'
            ]);
            exit;
        }

        $todayRuns = leGetRunsToday($db, (string) $gameId, (int) $currUser->id, $ipHash);
        if ($todayRuns >= $enthusiastDailyCap) {
            echo json_encode([
                'ok' => false,
                'code' => 'ENTH_CAP',
                'message' => 'You’ve used your 1 Powerball run for today. Come back tomorrow—or upgrade for unlimited access.'
            ]);
            exit;
        }

        leBumpRunsToday($db, (string) $gameId, (int) $currUser->id, $ipHash);

        echo json_encode([
            'ok' => true,
            'code' => 'ENTH_OK',
            'message' => 'Daily run unlocked.'
        ]);
        exit;
    }

    // Paid/other allowed groups: OK (no cap here)
    echo json_encode([
        'ok' => true,
        'code' => 'OK',
        'message' => 'Access granted.'
    ]);
    exit;
}

/**
 * Retrieve the next upcoming draw_date for a given lottery.
 *
 * @param   string $gameId     The lotterys game ID (e.g. '101').
 * @param   string $stateAbbr  Two-letter lower-cased state abbrevi

// --- LOAD LOTTERIES.JSON & DETERMINE tableName -------------------
$specsFile = realpath('/home/oscara/web/lottoexpert.net/public_html/lotteries.json');
if (!$specsFile || !is_readable($specsFile)) {
    die('Lottery specs file not found or unreadable.');
}
$specsContent = file_get_contents($specsFile);
$specsData = json_decode($specsContent, true);
if (json_last_error() !== JSON_ERROR_NONE) {
    die('Error parsing lotteries.json: ' . json_last_error_msg());
}

$foundSpec = null;
foreach ($specsData['lotteries'] as $lot) {
    if ((string)$lot['gameId'] === (string)$gameId) {
        $foundSpec = $lot;
        break;
    }
}
if (!$foundSpec) {
    die("Lottery spec for game ID $gameId not found in lotteries.json");
}


// THIS is the exact DB table from your JSON:
$tableName = $foundSpec['tableName'];  // e.g. "#__lotterydb_pa"



// --- NEW getNextDrawDate() -------------------------------------
// --- NEW getNextDrawDate() -------------------------------------
/**
 * Retrieves the next non-blank next_draw_date, expanding #__ prefix.
 * Returns DATETIME (adds ' 00:00:00' if the source is DATE-only).
 */
function getNextDrawDate($gameId, $db, $tableName) {
    // Extract suffix from #__tablename pattern, then build full name safely
    if (strpos($tableName, '#__') === 0) {
        // Has #__ prefix, extract suffix
        $suffix = substr($tableName, 3);
        if (empty(trim($suffix))) {
            throw new \RuntimeException('Invalid table name pattern in getNextDrawDate: empty suffix');
        }
        $fullTableName = $db->getPrefix() . $suffix;
    } else {
        // No #__ prefix, use as-is with prefix
        if (empty(trim($tableName))) {
            throw new \RuntimeException('Invalid table name pattern in getNextDrawDate: empty table name');
        }
        $fullTableName = $db->getPrefix() . $tableName;
    }
    $tbl = $db->quoteName($fullTableName);
    $q   = $db->getQuery(true)
        ->select($db->quoteName('next_draw_date'))
        ->from($tbl)
        ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
        ->where($db->quoteName('next_draw_date') . ' IS NOT NULL')
        ->where($db->quoteName('next_draw_date') . " <> " . $db->quote('0000-00-00'))
        ->where($db->quoteName('next_draw_date') . " <> " . $db->quote('0000-00-00 00:00:00'))
        ->order($db->quoteName('draw_date') . ' DESC')
        ->setLimit(1);
    $db->setQuery($q);
    $val = $db->loadResult();

    // Normalize DATE to DATETIME for inserts downstream
    if (!empty($val) && preg_match('/^\d{4}-\d{2}-\d{2}$/', $val)) {
        $val .= ' 00:00:00';
    }
    return $val ?: null;
}


// PROCESS SAVE PREDICTION SET (Place after current user is loaded, before any HTML output)
if ($_SERVER['REQUEST_METHOD'] === 'POST' && JSession::checkToken() && isset($_POST['save_set'])) {

    // -- Prevent saving empty predictions --
    if (empty($_POST['main_numbers'])) {
        $app->enqueueMessage('Please run the AI analysis before saving.', 'error');
        $app->redirect($_SERVER['REQUEST_URI']);
        exit;
    }

    $lottery   = filter_input(INPUT_POST, 'lottery_id',        FILTER_VALIDATE_INT);
    $src       = $db->quote(strip_tags(trim($_POST['source'])));
    $lbl       = $db->quote(strip_tags(trim($_POST['label'])));
    $main      = $db->quote(strip_tags(trim($_POST['main_numbers'])));
    $extra     = $db->quote(strip_tags(trim($_POST['extra_ball_numbers'])));
    $count     = filter_input(INPUT_POST, 'draws_analyzed',   FILTER_VALIDATE_INT);
    $gen       = $db->quote(strip_tags(trim($_POST['generated_at'])));
    $saved     = $db->quote(date('Y-m-d H:i:s'));
    $epochs    = (int)   $_POST['epochs'];
    $batchSize = (int)   $_POST['batch_size'];
    $dropout   = (float) $_POST['dropout_rate'];
    $lr        = (float) $_POST['learning_rate'];
    $actFunc   = $db->quote(strip_tags(trim($_POST['activation_function'])));
    $layers    = (int)   $_POST['hidden_layers'];
    $recencyDecay  = (float) $_POST['recency_decay'];


    // ? lookup the Joomla lottery PK by game_id (no state abbreviations)
    $q = $db->getQuery(true)
        ->select('l.game_id')
        ->from( $db->quoteName($db->getPrefix() . 'lotteries','l') )
        ->where('l.lottery_id = ' . $lottery);
    $db->setQuery($q);
    $gameDbId = $db->loadResult();

// ? fetch next draw_date using our JSON-driven $tableName
$nextDraw = getNextDrawDate($gameDbId, $db, $tableName);

// Guard: fail clearly to avoid inserting 0000-00-00
if (empty($nextDraw)) {
    $app->enqueueMessage('Could not resolve next_draw_date for this game. Please confirm the draw table has it populated.', 'error');
    $app->redirect($_SERVER['REQUEST_URI']);
    exit;
}

// (removed redundant $query build)

    // ? build INSERT with next_draw_date column
    $ins = $db->getQuery(true)
        ->insert($db->quoteName($db->getPrefix() . 'user_saved_numbers'))
        ->columns([
  'user_id','lottery_id','main_numbers','extra_ball_numbers',
  'source','label','draws_analyzed','generated_at','date_saved',
  'next_draw_date', 'epochs', 'batch_size', 'dropout_rate',
  'learning_rate', 'activation_function', 'hidden_layers', 'recency_decay'
])
        ->values(
  (int)$currUser->id . ", $lottery, $main, $extra, "
  . "$src, $lbl, $count, $gen, $saved, "
  . $db->quote($nextDraw) . ", $epochs, $batchSize, $dropout, $lr, $actFunc, $layers"
  . ", $recencyDecay"
);

    try {
        $db->setQuery($ins);
        $db->execute();
        $app->enqueueMessage('Number set saved successfully.');
        $app->redirect('/my-dashboard');
        exit;
    } catch (Exception $e) {
        $app->enqueueMessage('Error saving number set: ' . $e->getMessage(), 'error');
    }
}

// — The rest of your file (re-initialization, JSON config read, the full HTML/CSS/JS) stays exactly the same. — 
// Paste the remainder of your original file here without changes.


// Get the application instance
$app = \JFactory::getApplication('site');


// Prevent direct access to the file
defined('_JEXEC') or die('Restricted access');

// Path to the JSON settings file
$configFile = '/home/oscara/web/lottoexpert.net/public_html/settings2.json';

// Check if the file exists
if (!file_exists($configFile)) {
    die('Configuration file not found.');
}

// Read and decode the JSON configuration
$configContent = file_get_contents($configFile);
$config = json_decode($configContent, true);

// Check for JSON parsing errors
if (json_last_error() !== JSON_ERROR_NONE) {
    die('Error parsing configuration file: ' . json_last_error_msg());
}


// Ensure the game ID exists in the configuration
if (!isset($config[$gameId])) {
    die("Game ID $gameId not found in the configuration.");
}

// Lookup the Joomla lotteries.lottery_id by that game_id so we pass the correct PK into our save handler

$queryLottery = $db->getQuery(true)
    ->select($db->quoteName('lottery_id'))
    ->from($db->quoteName($db->getPrefix() . 'lotteries'))
    ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId));
$db->setQuery($queryLottery);
$lottery_id = (int)$db->loadResult();

// Load the game-specific settings
$gameConfig        = $config[$gameId];
$epochs            = $gameConfig['epochs']            ?? null;
$batchSize         = $gameConfig['batchSize']         ?? null;
$dropoutRate       = $gameConfig['dropoutRate']       ?? null;
$learningRate      = $gameConfig['learningRate']      ?? null;
$activationFunction= $gameConfig['activationFunction']?? null;
$hiddenLayers      = $gameConfig['hiddenLayers']      ?? null;

// Validate extracted parameters...
if (!is_numeric($epochs) || $epochs <= 0) {
    die('Invalid value for "epochs". Must be a positive number.');
}
if (!is_numeric($batchSize) || $batchSize <= 0) {
    die('Invalid value for "batchSize". Must be a positive number.');
}
if (!is_numeric($dropoutRate) || $dropoutRate < 0 || $dropoutRate > 1) {
    die('Invalid value for "dropoutRate". Must be between 0 and 1.');
}
if (!is_numeric($learningRate) || $learningRate <= 0) {
    die('Invalid value for "learningRate". Must be greater than 0.');
}
if (!in_array($activationFunction, ['relu','sigmoid','tanh'], true)) {
    die('Invalid value for "activationFunction".');
}
if (!is_numeric($hiddenLayers) || $hiddenLayers <= 0) {
    die('Invalid value for "hiddenLayers". Must be a positive number.');
}


// Map the JSON fields into our variables
$mainNumbersMax = (int) $foundSpec['rangeMain'];       // e.g. 70
$pickSize       = (int) $foundSpec['pickSize'];        // e.g. 5 or 6
$numExtraBalls  = (int) $foundSpec['extraBallCount'];   // 0, 1, or 2
$hasExtraBall   = $numExtraBalls > 0;
$extraBallMax   = $hasExtraBall
                    ? (int) $foundSpec['rangeExtra']
                    : 0;                               // e.g. 25

// Derive a SKAI game type for presets (Option B – game-aware)
$skaiGameType = 'jackpot'; // default

// Very small-range daily games (e.g. Pick 3 / Pick 4)
if ($pickSize <= 4 && $mainNumbersMax <= 10) {
    $skaiGameType = 'daily';
}
// Classic Pick 5, no bonus ball
elseif ($pickSize === 5 && !$hasExtraBall) {
    $skaiGameType = 'pick5';
}
// Games with 2 or more extra balls (e.g. EuroMillions style)
elseif ($hasExtraBall && $numExtraBalls >= 2) {
    $skaiGameType = 'multiExtra';
}
// Otherwise, treat as jackpot-style (Powerball, Mega Millions, etc.)

// -- HARD-CODED COLUMN NAMES & SLICING --

// We’ve locked these in for security; we’ll only ever use the first $pickSize
// (plus any extra balls) out of this master list:
$allNumberFields = [
  'first','second','third','fourth','fifth','sixth','seventh',
  'eighth','nineth','tenth','eleventh','twelveth','thirtheenth',
  'fourteenth','fifteenth','sixteenth','seventeenth','eighteenth',
  'nineteenth','twentieth','twenty_first','twenty_second'
];

// pick the columns for the main draw:
$mainFieldNames  = array_slice($allNumberFields, 0, $pickSize);

// pick the columns for any extra-ball(s) (will be empty if none):
$extraFieldNames = $hasExtraBall
    ? array_slice($allNumberFields, $pickSize, $numExtraBalls)
    : [];
// -- end HARD-CODED COLUMN NAMES --

// (A) Helper to compute “n choose k”
function combination($n, $k) {
    if ($k > $n) return 0;
    $res = 1;
    for ($i = 1; $i <= $k; $i++) {
        $res = $res * ($n - $i + 1) / $i;
    }
    return round($res);
}

// (B) Total ways to pick $pickSize from $mainNumbersMax
$totalCombinations = combination($mainNumbersMax, $pickSize);

// -- DYNAMIC BUCKETS BLOCK START --

// 1) grab any custom from GET/POST
$custom = isset($_REQUEST['customCount']) ? (int) $_REQUEST['customCount'] : null;

// 2) build the raw list: always include 1 ticket, stock buckets, and custom
$raw = [
  $pickSize,  // “1 ticket”
  10, 15, 20, // stock buckets
  $custom     // optional custom
];

// 3) filter invalid, dedupe & sort
$options = array_values(array_unique(array_filter(
    $raw,
    function($n) use($pickSize, $mainNumbersMax) {
        return is_int($n)
            && $n >= $pickSize
            && $n <= $mainNumbersMax;
    }
)));
sort($options);

// 4) build stats
$stats = [];
foreach ($options as $opt) {
    $ways = combination($opt, $pickSize);
    $odds = $ways ? round($totalCombinations / $ways) : 0;
    $stats[] = [
        'count' => $opt,
        'ways'  => $ways,
        'odds'  => $odds,
        'pct'   => $ways
                   ? round(100 * $ways / $totalCombinations, 2)
                   : 0
    ];
}

// (E) Grab the “best” (last) row for headlines
$best = end($stats);

// -- DYNAMIC BUCKETS BLOCK END --


// Securely connect to the Joomla database

// Extract suffix from #__tablename pattern, then build full name safely
if (strpos($foundSpec['tableName'], '#__') === 0) {
    // Has #__ prefix, extract suffix
    $tableSuffix = substr($foundSpec['tableName'], 3);
    if (empty(trim($tableSuffix))) {
        die('Invalid table name pattern in lottery specs: empty suffix');
    }
    $fullDbTableName = $db->getPrefix() . $tableSuffix;
} else {
    // No #__ prefix, use as-is with prefix
    if (empty(trim($foundSpec['tableName']))) {
        die('Invalid table name pattern in lottery specs: empty table name');
    }
    $fullDbTableName = $db->getPrefix() . $foundSpec['tableName'];
}
$dbCol = $db->quoteName($fullDbTableName);


$gameIdCol = $db->quoteName('game_id');
$drawDateCol = $db->quoteName('draw_date');

// Prepare the SQL query securely
$query = $db->getQuery(true)
    ->select('*') // Include the game_name field
    ->from($dbCol)
    ->where($gameIdCol . ' = ' . $db->quote($gameId))
    ->order($drawDateCol . ' ASC');

$db->setQuery($query);
$historicalResults = $db->loadObjectList();

// Extract the lottery name from the database or default to 'Lottery' if not found
$lotteryName = isset($historicalResults[0]->game_name) ? $historicalResults[0]->game_name : 'Lottery';

// Count the total number of database entries
$totalEntryCount = count($historicalResults);

// Initialize variables
$draws = [];
$nearestDrawNumbers = [];
$nearestDrawDate = '';

// ---------------------------------------------------------------
// Use the actual last draw_date from the DB instead of today
if (!empty($historicalResults)) {
    // $historicalResults is ordered by draw_date ASC
    $lastRow        = end($historicalResults);
    $latestDrawDate = date('Y-m-d', strtotime($lastRow->draw_date));
} else {
    // Fallback if no history present
    $latestDrawDate = date('Y-m-d');
}
// ---------------------------------------------------------------

if (!empty($historicalResults)) {
    foreach ($historicalResults as $lr) {
        // Collect historical draw numbers and date

// build the numbers array dynamically based on our slices
$numbers = [];
// main balls
foreach ($mainFieldNames as $col) {
  $numbers[] = intval($lr->{$col});
}
// extra ball(s)
foreach ($extraFieldNames as $col) {
  $numbers[] = intval($lr->{$col});
}

        $draws[] = [
            'numbers'   => $numbers,
            'draw_date' => $lr->draw_date
        ];
    }

    // Use the latest draw as the input for Analysis
    $latestDrawData      = end($draws);
    $latestResult        = $latestDrawData['numbers'];
    $latestDrawDateFromDB = date('Y-m-d', strtotime($latestDrawData['draw_date']));

    // Find the draw nearest to the selected date
    $selectedDrawDate = isset($_POST['latestDrawDate'])
        ? $_POST['latestDrawDate']
        : $latestDrawDate;  // now correctly set from DB
    $nearestDraw = null;

    foreach ($draws as $draw) {
        if (new DateTime($draw['draw_date']) <= new DateTime($selectedDrawDate)) {
            $nearestDraw = $draw;
        } else {
            break;
        }
    }

    if ($nearestDraw) {
        $nearestDrawNumbers = $nearestDraw['numbers'];
        $nearestDrawDate    = $nearestDraw['draw_date'];
    }
}

?>

[[!DOCTYPE html]]
[[html]]
[[head]]
  [[meta charset="UTF-8"]]
[[title]]
  <?php
    // Use the JSON 'state' value directly
    $state     = $foundSpec['state'];       // e.g. "Multi-State"
    $today     = date('F j, Y');            // e.g. "July 8, 2025"
    $fullTitle = "$lotteryName – $state – $today | LottoExpert";

    // Output the actual <title> tag
    echo '[[title]]' . htmlspecialchars($fullTitle, ENT_QUOTES, 'UTF-8') . '[[/title]]';
  ?>
[[/title]]



[[link rel="preconnect" href="https://fonts.googleapis.com"]]
[[link rel="preconnect" href="https://fonts.gstatic.com" crossorigin]]

[[link rel="preload" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" as="style" onload="this.rel='stylesheet'"]]
[[noscript]]
  [[link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet"]]
[[/noscript]]

[[style id="critical-above-the-fold"]]
:root{
  --system-stack:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji",sans-serif;
}
/* Make the hero title render immediately with a system stack (webfont swaps in later) */
.ai-powerball-prediction h1{
  font-family:var(--system-stack);
  font-weight:700;
  line-height:1.2;
  margin:0 0 .25rem;
  font-size:clamp(28px,3.2vw,40px);
}
/* Keep paragraph visible right away too */
.ai-powerball-prediction > p{
  font-family:var(--system-stack);
}
[[/style]]

[[style]]
:root{
  --system-stack:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji",sans-serif;

  /* SKAI flat colors */
  --skai-blue:#1C66FF;
  --skai-navy:#0A1A33;
  --skai-sky:#EFEFF5;
  --skai-slate:#7F8DAA;
  --skai-success:#20C997;
  --skai-amber:#F5A623;

  /* SKAI gradients */
  --skai-gradient-primary:linear-gradient(135deg,#0A1A33 0%,#1C66FF 100%);
  --skai-gradient-radiant:linear-gradient(135deg,#1C66FF 0%,#7F8DAA 100%);
  --skai-gradient-slate:linear-gradient(180deg,#EFEFF5 0%,#FFFFFF 100%);
}

/* Global styles */
body {
  font-family: 'Roboto', var(--system-stack);
  font-size: 16px;
  line-height: 1.5;
  background: var(--skai-gradient-slate);
  color: var(--skai-navy);
  margin: 0;
  padding: 0;
}

/* Main container for analysis module */
.ai-powerball-prediction {
  background-color: #ffffff;
  border-radius: 16px;
  padding: 32px;
  text-align: center;
  margin: 32px auto;
  max-width: 960px;
  box-shadow: 0 18px 45px rgba(10,26,51,0.18);
  border: 1px solid rgba(127,141,170,0.18);
}

/* Headings */
.ai-powerball-prediction h1{
  font-family:var(--system-stack);
  font-weight:700;
  line-height:1.2;
  margin:0 0 .5rem;
  font-size:clamp(28px,3.2vw,40px);
  color:var(--skai-navy);
}

.ai-powerball-prediction h2 {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 20px;
  color: var(--skai-blue);
  letter-spacing: 0.03em;
}

.ai-powerball-prediction h3 {
  font-size: 22px;
  font-weight: 600;
  margin-top: 20px;
  margin-bottom: 12px;
  color: var(--skai-blue);
}
.ai-powerball-prediction h4 {
  font-size: 18px;
  font-weight: 600;
  margin-top: 16px;
  margin-bottom: 10px;
  color: var(--skai-navy);
}

/* Buttons */
button {
  padding: 12px 20px;
  font-size: 16px;
  background-color: var(--skai-blue);
  color: #fff;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  margin-top: 10px;
  font-weight: 600;
  letter-spacing: 0.01em;
}

button:hover {
  background-color: #144BDD;
}

button:disabled {
  background-color: rgba(127,141,170,0.6);
  cursor: not-allowed;
}

/* Secondary / neutral actions (e.g., Reset) */
button.button-reset{
  background-color: #ffffff;
  color: var(--skai-slate);
  border:1px solid rgba(127,141,170,0.6);
}
button.button-reset:hover{
  background-color:#f5f7fb;
}

/* Parameter inputs styling */
.parameter-inputs {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  gap: 20px;
  margin-top: 20px;
}

/* SKAI Mode strip (Balanced / Explorative / Conservative) */
.skai-mode-strip {
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  justify-content:center;
  align-items:center;
  margin:18px auto 8px auto;
}

.skai-mode-label {
  font-size:0.9rem;
  color:var(--skai-slate);
  margin-right:4px;
}

.skai-mode-btn {
  border-radius:999px;
  border:1px solid rgba(127,141,170,0.5);
  background:#ffffff;
  color:var(--skai-navy);
  padding:6px 14px;
  font-size:0.9rem;
  font-weight:500;
  cursor:pointer;
  transition:background 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, color 0.15s ease;
}

.skai-mode-btn:hover {
  background:#f5f7fb;
  box-shadow:0 4px 10px rgba(10,26,51,0.1);
}

.skai-mode-btn.is-active {
  background:var(--skai-gradient-radiant);
  color:#ffffff;
  border-color:transparent;
  box-shadow:0 6px 16px rgba(10,26,51,0.22);
}

.skai-mode-description {
  text-align:center;
  font-size:0.9rem;
  color:var(--skai-navy);
  margin:4px auto 10px auto;
  max-width:640px;
}

.parameter-inputs .parameter-item {
  flex: 1 1 200px;
  margin: 10px;
}

.parameter-inputs label {
  display: block;
  font-weight: 500;
  margin-bottom: 5px;
  color: var(--skai-navy);
}

.parameter-inputs input,
.parameter-inputs select {
  padding: 8px;
  border-radius: 8px;
  border: 1px solid rgba(127,141,170,0.55);
  width: 100%;
  font-size: 14px;
}

/* Countdown and progress message */
.countdown {
  font-size: 15px;
  font-weight: 500;
  margin-top: 15px;
  color: var(--skai-slate);
}

/* Parameter display box */
#parameterDisplay {
  background: var(--skai-gradient-radiant);
  color: #fff;
  padding: 16px 20px;
  border-radius: 12px;
  margin-top: 24px;
  font-size: 14px;
  text-align:left;
}

#parameterDisplay h3{
  color:#ffffff;
  margin-top:0;
  margin-bottom:12px;
}

.parameterDisplayItem {
  display: inline-flex;
  flex-wrap: wrap;
  gap:4px;
  align-items: baseline;
  margin: 3px 12px 3px 0;
}

.parameterDisplayItem label {
  font-weight: 600;
  color: rgba(255,255,255,0.8);
}

.parameterDisplayItem span {
  color: #ffffff;
  font-weight: 600;
}

/* Number ball styling — reserve fixed size to prevent layout shifts */
.number-ball {
  flex: 0 0 60px;
  border-radius: 50%;
  background-color: #ffffff;
  color: var(--skai-blue);
  width: 60px;
  height: 60px;
  line-height: 60px;
  font-size: 22px;
  font-weight: 700;
  text-align: center;
  margin: 10px 5px;
  box-shadow: 0px 4px 10px rgba(10,26,51,0.12);
  border: 2px solid rgba(127,141,170,0.5);
}

/* Extra / bonus variant */
.number-ball.powerball {
  flex: 0 0 60px;
  background-color: var(--skai-blue);
  color: #ffffff;
  border-color: #144BDD;
  box-shadow: 0px 4px 12px rgba(10,26,51,0.25);
}

/* Highlighting for matching numbers in backtesting */
.match {
  background-color: var(--skai-amber);
  color: #000;
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

/* Loading animation */
.loading .fun-message {
  font-size: 14px;
  margin-bottom: 4px;
  color: var(--skai-slate);
}

.loading .spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid var(--skai-blue);
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 8px auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Progress bar */
.progress-bar-container {
  background-color: #e0e7ed;
  border-radius: 999px;
  overflow: hidden;
  margin-top: 10px;
  width: 100%;
}

.progress-bar {
  background: var(--skai-gradient-primary);
  height: 20px;
  width: 0%;
  text-align: center;
  color: #fff;
  line-height: 20px;
  font-size:12px;
  transition: width 0.4s ease;
}

/* Analysis result section */
#prediction {
  margin-top: 24px;
  display: none;
}

#prediction h3 {
  text-align: center;
  color: var(--skai-blue);
}

#predictedNumbers {
  display: flex !important;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 20px;
}

/* Breakdown section */
.breakdown-section {
  background-color: #ffffff;
  color: var(--skai-navy);
  padding: 20px;
  border-radius: 12px;
  margin-top: 24px;
  border: 1px solid rgba(127,141,170,0.3);
}

.breakdown-section h3 {
  margin-bottom: 15px;
  color: var(--skai-blue);
}

.breakdown-section table {
  width: 100%;
  border-collapse: collapse;
}

.breakdown-section th, .breakdown-section td {
  border: 1px solid rgba(127,141,170,0.3);
  padding: 8px;
  text-align: center;
  font-size:14px;
}

.breakdown-section th {
  background-color: var(--skai-blue);
  color: #fff;
}

/* Custom container for detailed explanations */
.custom-container {
  font-size: 14px;
  line-height: 1.6;
  text-align: left;
  max-width: 720px;
  margin: 20px auto;
  padding: 20px 24px;
  background-color: #ffffff;
  border: 1px solid rgba(127,141,170,0.28);
  border-radius: 12px;
}

/* Explanation section */
.explanation-section {
  background-color: #ffffff;
  color: var(--skai-navy);
  padding: 20px;
  border-radius: 12px;
  margin-top: 20px;
  font-size: 14px;
  line-height: 1.8;
  border: 1px solid rgba(127,141,170,0.3);
}

/* Backtesting notice and results */
#backtestNotice, #backtestResults {
  background-color: #ffffff;
  color: var(--skai-navy);
  padding: 15px;
  border-radius: 8px;
  margin-top: 20px;
  border: 1px solid rgba(127,141,170,0.3);
}

#backtestProgressContainer {
  margin-top: 10px;
}

/* Reserve initial space for the hero card’s top area to minimize CLS */
.ai-powerball-prediction{
  min-height: 120px;
}

/* Button area: keep height stable even before fonts load */
.ai-powerball-prediction [style*="text-align: center; margin-top: 20px;"]{
  min-height: 56px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .parameter-inputs {
    flex-direction: column;
    align-items: center;
  }
  .parameter-item {
    width: 100%;
    max-width: 320px;
  }
}

/* SKAI mode selector – Balanced / Explorative / Conservative */
.skai-mode-strip {
  max-width: 960px;
  margin: 18px auto 10px auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
}

.skai-mode-btn {
  border-radius: 999px;
  padding: 8px 14px;
  border: 1px solid rgba(127,141,170,0.5);
  background-color: #ffffff;
  color: var(--skai-navy);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.skai-mode-btn span.skai-mode-label {
  text-transform: uppercase;
  letter-spacing: 0.06em;
  font-size: 11px;
}

.skai-mode-btn[aria-pressed="true"] {
  background: var(--skai-gradient-radiant);
  color: #ffffff;
  border-color: transparent;
  box-shadow: 0 8px 20px rgba(10,26,51,0.18);
}

.skai-mode-desc {
  max-width: 720px;
  margin: 6px auto 18px auto;
  font-size: 13px;
  color: var(--skai-slate);
  text-align: center;
  line-height: 1.6;
}

@media (max-width: 640px) {
  .skai-mode-strip {
    flex-direction: column;
    align-items: stretch;
  }
  .skai-mode-btn {
    justify-content: center;
  }
}



[[/style]]
[[script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js" defer]][[/script]]
[[script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" defer]][[/script]]


[[/head]]
[[body]]
[[div class="ai-powerball-prediction"]]
  <?php
    $state       = $foundSpec['state'];
    $today       = date('F j, Y');
    $headingText = "$lotteryName – $state – $today";
  ?>
  [[h1]]AI-Powered Lottery Prediction Analysis for <?php echo htmlspecialchars($headingText, ENT_QUOTES, 'UTF-8'); ?>[[/h1]]
[[p]]
  Unlock a clear, data-driven prediction powered by SKAI — our transparent AI engine. 
  Review how the model performed on past draws, see your numbers ranked by probability, 
  and decide how to play with more clarity and control.
[[/p]]
   
    <!-- Start Analysis Buttons -->
<?php if ($userIsInAllowedGroup): ?>
      [[div style="text-align: center; margin-top: 20px;"]]
[[button id="startPrediction" type="button"
   style="
     display:block;
     width:100%;
     max-width:320px;
     margin:0 auto;
   "]]
  Start Analysis
[[/button]]
[[button onclick="location.reload()" type="button" class="button-reset" style="margin-left:10px;"]]
  Reset
[[/button]]
      <?php if ($isEnthusiast && (string)$gameId === (string)$powerballGameId): ?>
        [[p style="margin:10px auto 0; max-width:640px; color:#6b7280; font-size:13px; line-height:1.45;"]]
          Lottery Enthusiast Access: 1 Powerball run per day—plus the ability to save your predictions.
        [[/p]]
      <?php endif; ?>
      [[/div]]
    <?php else: ?>
      [[div style="text-align: center; margin-top: 20px;"]]
        [[button type="button"
          style="padding: 10px 20px; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;"
          onclick="showSignUpPopup()"
        ]]
          Start Analysis
        [[/button]]
        [[button type="button"
          style="padding: 10px 20px; background-color: #ccc; color: black; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;"
          onclick="showSignUpPopup()"
        ]]
          Reset
        [[/button]]
        [[p style="margin:10px auto 0; max-width:640px; color:#6b7280; font-size:13px; line-height:1.45;"]]
          Create a free Lottery Enthusiast account to run Powerball analysis and save your predictions.
        [[/p]]
      [[/div]]
[[style]]
/* Modal Styling – SKAI look */
#signupOverlay {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0; top: 0;
  width: 100%; height: 100%;
  background-color: rgba(0, 0, 0, 0.65);
  backdrop-filter: blur(4px);
}

#signupModal {
  background: #fff;
  border-radius: 16px;
  max-width: 480px;
  margin: 10% auto;
  padding: 2.5rem 2rem;
  text-align: center;
  box-shadow: 0 22px 50px rgba(10,26,51,0.35);
  font-family: var(--system-stack);
  position: relative;
  line-height: 1.6;
}

#signupModalClose {
  position: absolute;
  top: 16px;
  right: 20px;
  font-size: 1.75rem;
  font-weight: 400;
  color: var(--skai-slate);
  cursor: pointer;
}

.signup-btn {
  display: inline-block;
  background: var(--skai-gradient-primary);
  color: #fff;
  padding: 0.9em 1.8em;
  margin-top: 1.5em;
  font-size: 1.05em;
  font-weight: 600;
  border: none;
  border-radius: 999px;
  text-decoration: none;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.signup-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 25px rgba(10,26,51,0.25);
}
[[/style]]

[[div id="signupOverlay"]]
[[div id="signupModal"]]
    [[span id="signupModalClose"]][[/span]]
    [[h2 style="font-size:1.8em; margin-bottom:.5em;"]]
      Powerball Preview Is Free With Lottery Enthusiast
    [[/h2]]

    [[p id="signupModalMsg" style="font-size:1.05em; color:#444;"]]
      Create a free Lottery Enthusiast account to run Powerball analysis and save your predictions.
    [[/p]]

    [[p style="margin-top:1em; font-size:1.05em; color:#222; font-weight:500;"]]
      This is a premium analysis tool. Your free account unlocks a daily Powerball run and lets you save predictions to track your results over time.
    [[/p]]

    [[p style="margin-top:1.25em; font-size:0.95em; color:#666;"]]
      No hype. No false promises. Just transparent, data-driven tools built to help you play smarter—every time.
    [[/p]]

    [[div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:14px;"]]
      [[a class="signup-btn" href="/index.php?option=com_users&view=registration" target="_blank"]]
        Create Free Account
      [[/a]]
      [[a class="signup-btn" href="/membership/lottoexpert-subscriptions" target="_blank" style="background:rgba(255,255,255,0.12); border:1px solid rgba(255,255,255,0.22);"]]
        View Upgrades
      [[/a]]
    [[/div]]
  [[/div]]
[[/div]]

[[script]]
function showSignUpPopup() {
  document.getElementById('signupOverlay').style.display = 'block';
  document.body.style.overflow = 'hidden';
}

document.addEventListener('DOMContentLoaded', function () {
  const close = document.getElementById('signupModalClose');
  const overlay = document.getElementById('signupOverlay');

  close.addEventListener('click', function () {
    overlay.style.display = 'none';
    document.body.style.overflow = '';
  });

  overlay.addEventListener('click', function (e) {
    if (e.target === overlay) {
      overlay.style.display = 'none';
      document.body.style.overflow = '';
    }
  });
});
[[/script]]

<!-- Removed legacy runPredictionBtn gating script.
     Access is now controlled via PHP user group checks
     and the SKAI membership modal (showSignUpPopup). -->

    <?php endif; ?>
    
    <!-- Advanced Backtesting Section (moved below the Start Analysis buttons) -->
    [[div style="margin: 20px auto; padding: 10px; background: #f9f9f9; color: #333; border-radius: 5px; width: 60%; border: 1px solid #ddd; text-align: left; font-size: 14px;"]]
      [[h4]]Backtesting (Optional)[[/h4]]
      [[p]]
        Optionally enable backtesting to evaluate how your chosen settings would have performed on past draws. 
        This feature helps you analyze historical trends and refine your strategy without affecting your current analysis.
      [[/p]]
      [[label for="enableBacktest"]]
        [[input type="checkbox" id="enableBacktest" name="enableBacktest" style="margin-right: 8px;" /]]
        Enable Backtest
      [[/label]]
      [[label for="numDrawsBacktest"]]
  Select Number of Draws for Backtest:
  [[select id="numDrawsBacktest" name="numDrawsBacktest"]]
    [[option value="1"]]1 Draw[[/option]]
    [[option value="2"]]2 Draws[[/option]]
    [[option value="3"]]3 Draws[[/option]]
    [[option value="4"]]4 Draws[[/option]]
    [[option value="5"]]5 Draws[[/option]]
  [[/select]]
[[/label]]
    [[/div]]
    
    [[p]]Click "Start Analysis" to begin, or adjust the advanced settings below to customize your experience.[[/p]]
    [[p]]Analyzing from [[strong]]<?php echo $totalEntryCount; ?>[[/strong]] total database entries...[[/p]]

    <!-- SKAI Mode Presets (Balanced / Explorative / Conservative + SKAI Blend Modes) -->
    [[div class="skai-mode-strip" role="radiogroup" aria-label="Choose how SKAI should analyze this game"]]
      [[button
        type="button"
        class="skai-mode-btn"
        data-skai-mode="balanced"
        aria-pressed="true"
      ]]
        [[span class="skai-mode-label"]]Balanced[[/span]]
        [[span]]Everyday play – steady, game-tuned settings.[[/span]]
      [[/button]]

      [[button
        type="button"
        class="skai-mode-btn"
        data-skai-mode="mixed"
        aria-pressed="false"
      ]]
        [[span class="skai-mode-label"]]Mixed[[/span]]
        [[span]]Adaptive blend based on AI–Skip agreement.[[/span]]
      [[/button]]

      [[button
        type="button"
        class="skai-mode-btn"
        data-skai-mode="ai-forward"
        aria-pressed="false"
      ]]
        [[span class="skai-mode-label"]]AI-forward[[/span]]
        [[span]]Leans harder into the neural net signal.[[/span]]
      [[/button]]

      [[button
        type="button"
        class="skai-mode-btn"
        data-skai-mode="skip-dominant"
        aria-pressed="false"
      ]]
        [[span class="skai-mode-label"]]Skip-dominant[[/span]]
        [[span]]Leans harder into Skip & Hit dynamics.[[/span]]
      [[/button]]

      [[button
        type="button"
        class="skai-mode-btn"
        data-skai-mode="explorative"
        aria-pressed="false"
      ]]
        [[span class="skai-mode-label"]]Explorative[[/span]]
        [[span]]Chases recent patterns more aggressively.[[/span]]
      [[/button]]

      [[button
        type="button"
        class="skai-mode-btn"
        data-skai-mode="conservative"
        aria-pressed="false"
      ]]
        [[span class="skai-mode-label"]]Conservative[[/span]]
        [[span]]Stays closer to long-term behaviour.[[/span]]
      [[/button]]
    [[/div]]

    <!-- PATCH 7A: Live SKAI blend readout (AI ? vs Skip 1-?, plus ß and T) -->
    [[div id="skaiBlendReadout"
      style="margin-top:10px; padding:10px; border:1px solid rgba(0,0,0,0.12); border-radius:8px; font-weight:700; color:var(--skai-navy);"
      aria-live="polite"
    ]]
      Mode: balanced • AI ?: 0.65 • Skip: 0.35 • ß: 2.00 • T: 1.00
    [[/div]]

    [[p id="skaiModeDescription" class="skai-mode-desc skai-mode-description"]]
      Balanced mode uses game-specific defaults for <?php echo htmlspecialchars($lotteryName, ENT_QUOTES, 'UTF-8'); ?> – a steady choice for most sessions.
    [[/p]]

    [[div class="custom-container"]]
      [[details]]
        [[summary]]Training Parameters Explained[[/summary]]
        [[h4 style="margin-top: 10px;"]]Epochs[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] An epoch is one complete pass through the entire dataset.[[/p]]
        [[p]][[strong]]Typical Range:[[/strong]] 10 to 1000.[[/p]]
        [[ul style="padding-left: 20px; margin-top: 5px;"]]
          [[li]]Increasing epochs can help the model learn more patterns but may cause overfitting.[[/li]]
          [[li]]Decreasing epochs speeds training but may underfit the data.[[/li]]
        [[/ul]]
        [[h4 style="margin-top: 10px;"]]Batch Size[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] How many samples are processed at once before updating the model.[[/p]]
        [[p]][[strong]]Typical Range:[[/strong]] 8 to 256.[[/p]]
        [[ul style="padding-left: 20px; margin-top: 5px;"]]
          [[li]]Larger batch sizes speed up training but may miss finer details.[[/li]]
          [[li]]Smaller batches are more precise but slower.[[/li]]
        [[/ul]]
        [[h4 style="margin-top: 10px;"]]Dropout Rate[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] The fraction of neurons randomly ignored during training to prevent overfitting.[[/p]]
        [[p]][[strong]]Typical Range:[[/strong]] 0.1 to 0.5.[[/p]]
        [[ul style="padding-left: 20px; margin-top: 5px;"]]
          [[li]]Higher dropout reduces overfitting but can slow learning.[[/li]]
          [[li]]Lower dropout allows more learning but may overfit.[[/li]]
        [[/ul]]
        [[h4 style="margin-top: 10px;"]]Learning Rate[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] Controls how quickly the model adjusts its knowledge each step.[[/p]]
        [[p]][[strong]]Typical Range:[[/strong]] 0.0001 to 0.1.[[/p]]
        [[ul style="padding-left: 20px; margin-top: 5px;"]]
          [[li]]Higher rates learn faster but can skip important details.[[/li]]
          [[li]]Lower rates learn more carefully but slowly.[[/li]]
        [[/ul]]
        [[h4 style="margin-top: 10px;"]]Activation Function[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] The function that decides how a neuron fires. Introduces complexity to model patterns.[[/p]]
        [[p]][[strong]]Common Choices:[[/strong]] ReLU, Sigmoid, Tanh.[[/p]]
        [[h4 style="margin-top: 10px;"]]Hidden Layers[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] Layers between the input and output. More layers can detect more complex patterns.[[/p]]
        [[p]][[strong]]Typical Range:[[/strong]] 1 to 5.[[/p]]
        
        [[h4 style="margin-top: 10px;"]]Recency Decay[[/h4]]
        [[p]][[strong]]Definition:[[/strong]] Recency Decay controls how much we care about old draws versus new ones. If it’s 1.0, every draw is treated exactly the same. If it’s lower (like 0.8), each step back in time becomes a bit less important.[[/p]]
        [[p]][[strong]]Imagine this:[[/strong]] You collect a sticker each day. With 0.8 decay, yesterday’s sticker counts full, but the one from two days ago counts as 0.8×1=0.8, three days ago as 0.8×0.8=0.64, and so on.[[/p]]
        [[p]][[strong]]Why It Helps:[[/strong]] It lets the AI focus more on recent trends without forgetting the past completely.[[/p]]
        [[ul style="padding-left: 20px; margin-top: 5px;"]]
         [[li]]1.0 means “all days are equally important.”[[/li]]
         [[li]]0.9 means “each day back is 10% less important.”[[/li]]
         [[li]]0.5 makes older days fade very fast (half as important each step).[[/li]]
        [[/ul]]
        
        [[h4 style="margin-top: 10px;"]]What is Overfitting?[[/h4]]
        [[p]]Overfitting happens when the model memorizes the training data rather than learning general patterns. Using dropout and proper tuning helps prevent this.[[/p]]
      [[/details]]
    [[/div]]

    [[div class="custom-container"]]
      [[details]]
        [[summary]]Advanced Settings (Optional)[[/summary]]
        [[form id="predictionForm" onsubmit="return false;"]]
          [[div class="parameter-inputs"]]
            [[div class="parameter-item"]]
              [[label for="epochs"]]Epochs:[[br]]
                [[input type="number" id="epochs" name="epochs" value="<?php echo htmlspecialchars($epochs); ?>" min="1"]]
              [[/label]]
            [[/div]]
            [[div class="parameter-item"]]
              [[label for="batchSize"]]Batch Size:[[br]]
                [[input type="number" id="batchSize" name="batchSize" value="<?php echo htmlspecialchars($batchSize); ?>" min="1"]]
              [[/label]]
            [[/div]]
            [[div class="parameter-item"]]
              [[label for="dropoutRate"]]Dropout Rate:[[br]]
                [[input type="number" id="dropoutRate" name="dropoutRate" step="0.1" value="<?php echo htmlspecialchars($dropoutRate); ?>" min="0" max="1"]]
              [[/label]]
            [[/div]]
            [[div class="parameter-item"]]
              [[label for="learningRate"]]Learning Rate:[[br]]
                [[input type="number" id="learningRate" name="learningRate" step="0.0001" value="<?php echo htmlspecialchars($learningRate); ?>" min="0"]]
              [[/label]]
            [[/div]]
            [[div class="parameter-item"]]
              [[label for="activationFunction"]]Activation Function:[[br]]
                [[select id="activationFunction" name="activationFunction"]]
                  [[option value="relu" <?php echo $activationFunction === 'relu' ? 'selected' : ''; ?>]]ReLU[[/option]]
                  [[option value="sigmoid" <?php echo $activationFunction === 'sigmoid' ? 'selected' : ''; ?>]]Sigmoid[[/option]]
                  [[option value="tanh" <?php echo $activationFunction === 'tanh' ? 'selected' : ''; ?>]]Tanh[[/option]]
                [[/select]]
              [[/label]]
            [[/div]]
            [[div class="parameter-item"]]
              [[label for="hiddenLayers"]]Hidden Layers:[[br]]
                [[input type="number" id="hiddenLayers" name="hiddenLayers" value="<?php echo htmlspecialchars($hiddenLayers); ?>" min="1"]]
              [[/label]]
            [[/div]]
             [[div class="parameter-item"]]
               [[label for="recencyDecay"]]
                 Recency Decay (?):[[br]]
                 [[div style="display:flex; gap:10px; align-items:center;"]]
                   [[input
                     type="number"
                     id="recencyDecay"
                     name="recencyDecay"
                     step="0.01"
                     min="0"
                     max="1"
                     value="<?php echo htmlspecialchars($gameConfig['recencyDecay'] ?? 1); ?>"
                   ]]
                   [[span
                     id="recencyDecayLambdaReadout"
                     style="min-width:92px; text-align:right; font-weight:700; color:var(--skai-navy);"
                     aria-live="polite"
                   ]]
                     ? = 1.00
                   [[/span]]
                 [[/div]]
               [[/label]]
             [[/div]]
             [[div class="parameter-item"]]
              [[label for="latestDrawDate"]]Latest Draw Date:[[br]]
                [[input type="date" id="latestDrawDate" name="latestDrawDate" value="<?php echo htmlspecialchars($latestDrawDate); ?>"]]
              [[/label]]
            [[/div]]
          [[/div]]
        [[/form]]
      [[/details]]
    [[/div]]
    
    [[div id="parameterDisplay"]]

      [[h3]]Parameters Used for Analysis[[/h3]]
      [[div class="parameterDisplayItem"]]
        [[label]]Analysis Date and Time: [[/label]] [[span id="predictionDateValue"]]N/A[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Total Entry Count: [[/label]] [[span]]<?php echo $totalEntryCount; ?>[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Epochs: [[/label]] [[span id="epochValue"]]N/A[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Batch Size: [[/label]] [[span id="batchSizeValue"]]N/A[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Dropout Rate: [[/label]] [[span id="dropoutRateValue"]]N/A[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Learning Rate: [[/label]] [[span id="learningRateValue"]]N/A[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Activation Function: [[/label]] [[span id="activationFunctionValue"]]N/A[[/span]]
      [[/div]]
      [[div class="parameterDisplayItem"]]
        [[label]]Hidden Layers: [[/label]] [[span id="hiddenLayersValue"]]N/A[[/span]]
      [[/div]]
       [[div class="parameterDisplayItem"]]
       [[label]]Recency Decay (?): [[/label]] [[span id="recencyDecayValue"]]N/A[[/span]]
       [[/div]]
       [[div class="parameterDisplayItem"]]
         [[label]]Latest Draw Date: [[/label]] [[span id="latestDrawDateValue"]]N/A[[/span]]
      [[/div]]
      [[h3]]Drawn Numbers Used for Analysis Up to and Including[[/h3]]
      
     [[p]]
  Drawn Date: [[strong]]<?php echo $nearestDrawDate; ?>[[/strong]],
  Draw Numbers: [[strong]]<?php
    echo is_array($nearestDrawNumbers)
      ? implode(', ', $nearestDrawNumbers)
      : htmlspecialchars($nearestDrawNumbers, ENT_QUOTES, 'UTF-8');
  ?>[[/strong]]
[[/p]]
[[/div]]

    
    [[div id="countdown" class="countdown"]]Estimated time: Calculating...[[/div]]
    
    [[div id="loading" class="loading" style="display: none;"]]
      [[p id="funMessage" class="fun-message"]][[strong]]Humor Display:[[/strong]] Initializing...[[/p]]
      [[p id="progressMessage"]][[strong]]System Status:[[/strong]] Initializing...[[/p]]
      [[div class="spinner"]][[/div]]
      [[div class="progress-bar-container"]]
        [[div id="progressBar" class="progress-bar"]]0%[[/div]]
      [[/div]]
    [[/div]]
    
    [[div id="prediction" style="display: none;"]]
      [[h3]]Predicted Numbers[[/h3]]
      [[div id="predictedNumbers"]][[/div]]
    [[/div]]
    
    [[div class="breakdown-section" id="numberBreakdown" style="display: none;"]]
      [[h3]]Most Likely Number Breakdown[[/h3]]
      [[div id="numberBreakdownTable"]][[/div]]
    [[/div]]
    
    [[div id="backtestNotice" style="display: none; background: #ffffff; color: #000; padding: 15px; border-radius: 5px; margin-top: 20px; border: 1px solid #ccc;"]]
      [[h4]]Backtesting in Progress[[/h4]]
      [[p]]The system is now running a backtest on the completed draws using your selected settings. Please note that this process could take several minutes.[[/p]]
    [[/div]]
    [[div id="backtestProgressContainer" style="display: none; margin-top: 10px;"]]
      [[div id="backtestProgressBar" class="progress-bar"]]0%[[/div]]
    [[/div]]
    [[div id="backtestResults" style="display: none; margin-top: 20px;"]][[/div]]
    
    
      <!-- SAVE PREDICTION SET FORM (Place this after your main analysis container) -->
[[div id="saveFormContainer" style="background-color:#fff; border:1px solid #ccc; border-radius:10px; padding:10px 15px; font-size:13px; max-width:500px; margin:20px auto; text-align:center;"]]
    [[h4 style="margin-bottom:10px; font-size:15px; font-weight:bold;"]]Save This Prediction Set[[/h4]]
    [[form method="post" id="savePredictionForm" style="margin:0 auto;"]]
      <?php echo JHtml::_('form.token'); ?>
      [[input type="hidden" name="source" value="ai_prediction"]]
      [[input type="hidden" name="lottery_id" value="<?php echo $lottery_id; ?>"]]
      [[input type="hidden" name="main_numbers" id="saveMainNumbers"]]
      [[input type="hidden" name="extra_ball_numbers" id="saveExtraBallNumbers"]]
      [[input type="hidden" name="draws_analyzed" value="<?php echo $totalEntryCount; ?>"]]

      [[input type="hidden" name="generated_at" id="saveGeneratedAt" value=""]]
      [[input type="hidden" name="next_draw_date" id="saveNextDrawDate" value=""]]

      [[input type="hidden" name="epochs" id="saveEpochs"]]
      [[input type="hidden" name="batch_size" id="saveBatchSize"]]
      [[input type="hidden" name="dropout_rate" id="saveDropoutRate"]]
      [[input type="hidden" name="learning_rate" id="saveLearningRate"]]
      [[input type="hidden" name="activation_function" id="saveActivationFunction"]]
      [[input type="hidden" name="hidden_layers" id="saveHiddenLayers"]]
      [[input type="hidden" name="recency_decay" id="saveRecencyDecay"]]
      
      [[label style="display:block; font-weight:bold; margin:6px 0 2px;"]]Label[[/label]]
<?php $labelText = $lotteryName . " Prediction – " . date('M j, Y'); ?>
[[input type="text" name="label" id="saveLabel" value="<?php echo htmlspecialchars($labelText); ?>" style="width:100%; …"]]

      <?php if ($userCanSave): ?>
        [[button type="submit" name="save_set" style="margin-top:10px; padding:7px 15px; background-color:#007bff; color:#fff; border:none; border-radius:5px; font-weight:bold; font-size:13px;"]]
          Save to My LottoExpert
        [[/button]]
      <?php else: ?>
        <?php if ($isEnthusiast && (string)$gameId !== $powerballGameId): ?>
          [[p style="color:#888; font-style:italic; margin-top:10px; font-size:13px;"]]
            Your Enthusiast plan can save predictions only for Powerball.
          [[/p]]
        <?php else: ?>
          [[p style="color:#888; font-style:italic; margin-top:10px; font-size:13px;"]]
            Log in to save predictions.
          [[/p]]
        <?php endif; ?>
      <?php endif; ?>
    [[/form]]
[[/div]]
    
    
    
[[style]]
  /* Unified SKAI layout for all insight sections (probability, AI explainer, wheeling) */

  .lottery-analysis {
    max-width: 960px;
    margin: 32px auto;
    padding: 0 16px 32px;
    font-family: var(--system-stack);
    font-size: 16px;
    line-height: 1.5;
    color: var(--skai-navy);
  }

  .lottery-analysis section {
    margin-bottom: 24px;
  }

  .lottery-analysis h2 {
    font-size: 2rem;         /* 32px */
    line-height: 2.5rem;     /* 40px */
    font-weight: 700;
    margin-bottom: 1rem;
    color: var(--skai-blue);
    text-align:center;
  }

  .lottery-analysis h3 {
    font-size: 1.25rem;      /* 20px */
    line-height: 1.9rem;
    font-weight: 600;
    margin-bottom: 0.75rem;
    color: var(--skai-navy);
  }

  .lottery-analysis p {
    margin-bottom: 0.9rem;
    color: var(--skai-navy);
  }

  /* Core SKAI card used by all bottom sections */
  .tile {
    background-color: #ffffff;
    border-radius: 16px;
    padding: 24px 24px 20px;
    margin: 24px 0;
    box-shadow: 0 14px 36px rgba(10,26,51,0.12);
    border: 1px solid rgba(127,141,170,0.22);
  }

  /* When a tile sits inside another tile (e.g., inner breakdown card), make it lighter */
  .lottery-analysis .tile .tile {
    background-color: #f7f8fc;
    border-radius: 12px;
    box-shadow: none;
    border: 1px solid rgba(127,141,170,0.18);
    margin: 16px 0 0;
    padding: 16px 18px;
  }

  .tile table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1rem;
  }

  .tile th,
  .tile td {
    padding: 10px 12px;
    font-size: 0.875rem;     /* 14px */
    line-height: 1.25rem;    /* 20px */
    border-bottom: 1px solid rgba(127,141,170,0.25);
    text-align: center;
  }

  .tile th {
    background: var(--skai-blue);
    color: #fff;
  }

  .tile tr:nth-child(even) {
    background: #f9fbff;
  }

  .callout {
    background: #f1f4fb;
    padding: 12px 14px;
    margin-bottom: 18px;
    border-left: 4px solid var(--skai-blue);
    font-size: 0.95rem;
    line-height: 1.5;
    border-radius: 10px;
  }

  .callout-alt {
    border-left-color: var(--skai-amber);
  }

  /* Charts inside tiles – consistent aspect and breathing room */
  .tile canvas {
    width: 100% !important;
    height: 240px !important;
    display: block;
    margin-top: 16px;
  }

  @media (max-width: 600px) {
    .lottery-analysis {
      padding: 0 12px 24px;
    }
    .tile {
      margin: 16px 0;
      padding: 18px 16px;
    }
    .tile canvas {
      height: 200px !important;
    }
  }
[[/style]]


[[div class="lottery-analysis"]]

  [[nav aria-label="SKAI analysis steps" style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin:16px auto 12px auto; font-size:0.9rem;"]]
    [[span style="padding:4px 10px; border-radius:999px; background:#0A1A33; color:#ffffff; font-weight:600;"]]
      Step 1 – Choose your coverage
    [[/span]]
    [[span style="padding:4px 10px; border-radius:999px; background:#1C66FF; color:#ffffff; font-weight:600;"]]
      Step 2 – Run SKAI AI analysis
    [[/span]]
    [[span style="padding:4px 10px; border-radius:999px; background:#EFEFF5; color:#0A1A33; border:1px solid #d0d5e5;"]]
      Step 3 – Structure tickets with wheeling
    [[/span]]
  [[/nav]]

  [[section class="tile"]]

    [[h2 style="text-align:center; margin-bottom:15px; color:#1C66FF;"]]
      Why Choose [[strong]]<?php echo $best['count'] ?>[[/strong]] Numbers?
    [[/h2]]

    [[p style="text-align:center; font-size:16px;"]]
      Playing a lottery like <?php echo htmlspecialchars($lotteryName, ENT_QUOTES, 'UTF-8'); ?> can feel overwhelming.
      You pick [[strong]]<?php echo $pickSize ?>[[/strong]] numbers from [[strong]]<?php echo $mainNumbersMax ?>[[/strong]]
<?php if ($hasExtraBall): ?>
      and [[strong]]<?php echo $numExtraBalls; ?> extra ball<?php echo $numExtraBalls > 1 ? 's' : ''; ?> from [[strong]]<?php echo $extraBallMax ?>[[/strong]].
<?php endif; ?>
      [[br]]
      Did you know the chance of guessing the exact <?php echo $pickSize ?> numbers correctly is only
      [[strong]]1 in <?php echo number_format($totalCombinations) ?>[[/strong]]?
    [[/p]]

    [[p style="text-align:center; font-size:18px; font-weight:bold; color:#2a9d8f;"]]
      But if you choose [[strong]]<?php echo $best['count'] ?>[[/strong]] numbers, your chances improve dramatically to about:
    [[/p]]

    [[p style="text-align:center; font-size:22px; font-weight:bold; margin:10px 0; color:#e67e22;"]]
      1 in <?php echo number_format($best['odds']) ?>
    [[/p]]

    [[section class="tile"]]
      [[h3 style="margin-top:0; color:#2a5298;"]]Let's Break This Down Simply[[/h3]]

      [[table style="width:100%; border-collapse:collapse; text-align:center; font-size:14px; margin-top:10px;"]]
        [[thead]]
          [[tr style="background-color:#264653; color:#fff;"]]
            [[th style="padding:5px;"]]Your Numbers[[/th]]
            [[th style="padding:5px;"]]Ways to Match[[/th]]
            [[th style="padding:5px;"]]Odds[[/th]]
          [[/tr]]
        [[/thead]]
        [[tbody]]
          <?php foreach ($stats as $row): ?>
            [[tr style="<?php echo $row['count']==$best['count']
                          ? 'font-weight:bold;background-color:#e9f5f3;'
                          : '';?>"]]
              [[td style="padding:5px;"]]<?php echo $row['count'] ?> numbers[[/td]]
              [[td]]<?php echo number_format($row['ways']) ?> ways[[/td]]
              [[td]]1 in <?php echo number_format($row['odds']) ?>[[/td]]
            [[/tr]]
          <?php endforeach; ?>
        [[/tbody]]
      [[/table]]

      [[figure style="margin-top:10px; text-align:center;"]]
        [[canvas id="coverageChart" width="300" height="150" style="max-width:100%;"]][[/canvas]]
        [[figcaption style="font-size:0.8rem; color:#555; margin-top:5px;"]]
          More numbers = better coverage!
        [[/figcaption]]
      [[/figure]]

      [[p style="font-size:0.9rem; color:#555; margin-top:10px;"]]
        Notice each time you add more numbers, your coverage increases.
        Choosing <?php echo $best['count'] ?> numbers gives you the best balance
        between odds and cost.
      [[/p]]
    [[/section]]

  [[/section]]
[[/div]]



[[section class="tile mdc-card mdc-elevation--z1" role="region" aria-labelledby="ai-prediction-title" style="padding:24px; margin-top:24px;"]]
  
  [[h2 id="ai-prediction-title" class="mdc-typography--headline5" style="margin-bottom:4px; color:var(--primary-blue); text-align:center;"]]
    Step 2 – How SKAI Thinks About the Numbers
  [[/h2]]

  [[p class="mdc-typography--body1" style="margin-bottom:20px; line-height:1.6; text-align:center; max-width:640px; margin-left:auto; margin-right:auto;"]]
    This section shows, in plain language, how SKAI analyzes past draws and turns them into probability-based recommendations. No “magic,” no hype – just measured, transparent machine-learning.
  [[/p]]

  [[div class="step" style="margin-bottom:20px;"]]
    [[h3 class="mdc-typography--subtitle1" style="margin-bottom:6px; color:var(--text-main);"]]
      1. Gathering Clean, Reliable Data
    [[/h3]]
    [[p class="mdc-typography--body1" style="line-height:1.6;"]]
      SKAI starts with a verified history of past draws from our secure database. Each record includes:[[br/]]
      [[strong]]Winning numbers:[[?/strong]] the actual numbers drawn in each game.[[br/]]
      [[strong]]Draw dates:[[?/strong]] when each drawing took place.[[br/]]
      [[strong]]Jackpot amounts:[[?/strong]] prize size when available.[[br/]]
      [[strong]]Bonus-ball details:[[?/strong]] Powerball, EuroMillions stars, or other extra balls. [[br/]][[br/]]
      Automated checks look for duplicates, missing values, and format issues, so the model learns from consistent, trustworthy data.
    [[/p]]
  [[/div]]

  [[div class="step" style="margin-bottom:20px;"]]
    [[h3 class="mdc-typography--subtitle1" style="margin-bottom:6px; color:var(--text-main);"]]
      2. Preparing the Data for Learning
    [[/h3]]
    [[p class="mdc-typography--body1" style="line-height:1.6;"]]
      Raw draws are transformed into features the model can understand:[[br/]]
      [[strong]]Normalization:[[?/strong]] values are scaled so different ranges are comparable.[[br/]]
      [[strong]]Vector encoding:[[?/strong]] each draw becomes a consistent numeric “snapshot.”[[br/]]
      [[strong]]Outlier checks:[[?/strong]] unusual records are reviewed and, if needed, excluded.[[br/]]
      [[strong]]Time-based features:[[?/strong]] SKAI derives patterns like gaps between repeats and rolling averages over recent draws.
    [[/p]]
  [[/div]]

  [[div class="step" style="margin-bottom:20px;"]]
    [[h3 class="mdc-typography--subtitle1" style="margin-bottom:6px; color:var(--text-main);"]]
      3. Training the Neural Network
    [[/h3]]
    [[p class="mdc-typography--body1" style="line-height:1.6;"]]
      SKAI uses a deep neural network, tuned through a few key settings:
    [[/p]]
    [[dl style="margin-left:16px; line-height:1.6;"]]
      [[dt]][[strong]]Epochs:[[?/strong]][[/dt]]
      [[dd]]How many full passes the model makes through the data. More epochs allow deeper learning, up to a point.[[/dd]]

      [[dt]][[strong]]Batch size:[[?/strong]][[/dt]]
      [[dd]]How many past draws the model processes at once before updating itself. This balances speed and stability.[[/dd]]

      [[dt]][[strong]]Dropout rate:[[?/strong]][[/dt]]
      [[dd]]A fraction of “turned-off” neurons during training that helps prevent overfitting and keeps the model honest.[[/dd]]

      [[dt]][[strong]]Learning rate:[[?/strong]][[/dt]]
      [[dd]]How big a step the model takes when it learns from an error. Too high can be unstable; too low slows improvement.[[/dd]]

      [[dt]][[strong]]Activation function:[[?/strong]][[/dt]]
      [[dd]]Non-linear functions (ReLU, Sigmoid, Tanh) that let the network capture more than simple straight-line trends.[[/dd]]

      [[dt]][[strong]]Hidden layers:[[?/strong]][[/dt]]
      [[dd]]Stacked layers that move from basic frequencies to more subtle co-occurrence patterns between numbers.[[/dd]]
    [[/dl]]
    [[p class="mdc-typography--caption" style="margin-top:8px; color:var(--text-muted); font-style:italic;"]]
      A built-in validation split monitors for overfitting. If the validation quality stops improving, we adjust epochs, dropout, or other settings.
    [[/p]]
  [[/div]]

  [[div class="step" style="margin-bottom:20px;"]]
    [[h3 class="mdc-typography--subtitle1" style="margin-bottom:6px; color:var(--text-main);"]]
      4. Turning Patterns into Probabilities
    [[/h3]]
    [[p class="mdc-typography--body1" style="line-height:1.6;"]]
      After training, SKAI assigns a probability score to every possible number. From there, it:[[br/]]
      [[strong]]Ranks:[[?/strong]] orders all numbers from most to least likely, based on the learned patterns.[[br/]]
      [[strong]]Selects:[[?/strong]] chooses the top candidates (for example, 5 main numbers plus any required bonus balls) for your analysis view.
    [[/p]]
  [[/div]]

  [[div class="step" style="margin-bottom:20px;"]]
    [[h3 class="mdc-typography--subtitle1" style="margin-bottom:6px; color:var(--text-main);"]]
      5. Backtesting (Optional, but Recommended)
    [[/h3]]
    [[p class="mdc-typography--body1" style="line-height:1.6;"]]
      Before you trust any settings, you can replay them on past draws:[[br/]]
      [[strong]]Configure:[[?/strong]] pick how many draws to test and which metrics you care about (hits, matches, or custom rules).[[br/]]
      [[strong]]Review:[[?/strong]] compare actual vs. predicted results to see how that configuration behaved historically.
    [[/p]]
  [[/div]]

  [[div class="step" style="margin-bottom:20px;"]]
    [[h3 class="mdc-typography--subtitle1" style="margin-bottom:6px; color:var(--text-main);"]]
      6. Realistic, Responsible Use
    [[/h3]]
    [[p class="mdc-typography--body1" style="line-height:1.6;"]]
      SKAI narrows the field compared with picking numbers at random, but it cannot remove luck from the equation. Treat these insights as structured guidance, not a guarantee. Set a budget, stick to it, and play for enjoyment first.
    [[/p]]
  [[/div]]

  [[p class="mdc-typography--caption" style="margin-top:16px; color:var(--text-muted); text-align:center;"]]
    Built with ISO 9241-210 human-centered principles, W3C accessibility guidelines, and modern Material Design patterns – so the experience stays clear, ethical, and easy to use.
  [[/p]]

[[/section]]



  [[section class="tile"]]
    [[h3 style="margin-top:0; color:#2a5298;"]]
      Step 3 – Use Wheeling to Spread Your Coverage
    [[/h3]]

    [[p]]
      Wheeling takes a set of smart numbers – for example, the [[strong]]20[[/strong]] numbers SKAI highlights – and spreads them across multiple tickets in an organized way. Instead of relying on a single line, you cover more combinations from the same pool.
    [[/p]]

    [[table style="width:100%; border-collapse:collapse; text-align:center; font-size:14px; margin-top:10px;"]]
      [[tbody]]
        [[tr]]
          [[td style="padding:5px; background-color:#f0f4f8;"]]Full wheel (19 numbers)[[/td]]
          [[td]]11,628 tickets[[/td]]
        [[/tr]]
        [[tr]]
          [[td style="padding:5px; background-color:#f0f4f8;"]]Reduced wheel (19 numbers)[[/td]]
          [[td]]28 tickets[[/td]]
        [[/tr]]
        [[tr]]
          [[td style="padding:5px; background-color:#f0f4f8;"]]Guarantee[[/td]]
          [[td]]At least 3 numbers matched (if your pool hits)[[/td]]
        [[/tr]]
        [[tr]]
          [[td style="padding:5px; background-color:#f0f4f8;"]]Example cost (at $2 per ticket)[[/td]]
          [[td]]$56 total[[/td]]
        [[/tr]]
      [[/tbody]]
    [[/table]]

    [[p]]
      In plain terms, wheeling is a way to give your chosen numbers more “coverage” without needing to buy thousands of random tickets. You decide how many combinations fit your budget, and the wheel fills them in systematically.
    [[/p]]

    [[figure style="margin-top:10px; text-align:center;"]]
      [[canvas id="ticketsChart" width="300" height="150" style="max-width:100%;"]][[/canvas]]
      [[figcaption style="font-size:0.8rem; color:#555; margin-top:5px;"]]
        Full wheel vs. reduced wheel – similar coverage, far fewer tickets.
      [[/figcaption]]
    [[/figure]]

  [[/section]]

  [[div style="margin-top:15px; background-color:#eafaf1; padding:10px; border-radius:6px; border-left:4px solid #2a9d8f; font-size:0.9rem;"]]
    [[strong style="color:#264653;"]]Practical tip:[[br]][[/strong]]
    Let SKAI narrow the field to your best numbers, then apply a reduced wheel that fits your budget. This keeps your play structured, not scattered.
  [[/div]]

  [[div style="margin-top:10px; background-color:#e9f1fa; padding:10px; border-radius:6px; border-left:4px solid #2b7ae4; font-size:0.9rem;"]]
    [[strong style="color:#264653;"]]Perspective:[[br]][[/strong]]
    A 20-number selection can represent 15,504 different 5-number combinations. Wheeling does not guarantee a prize, but it can help you touch more of that space in a disciplined way.
  [[/div]]

  [[p style="margin-top:15px; font-style:italic; color:#555; font-size:0.9rem;"]]
    [[strong]]Important:[[br]][[/strong]]
    Lotteries always involve risk. SKAI and wheeling strategies are designed to help you play more thoughtfully, not to promise outcomes. Set clear limits, play within them, and treat any win as a positive surprise – not an expectation.
  [[/p]]






  
  [[script defer]]
    document.addEventListener('DOMContentLoaded', function() {
        function convertSorcererSyntaxToHTML(str) {
  return str.replace(/\[\[/g, '<').replace(/\]\]/g, '>');
}


// --- BEGIN: Define renderBacktestResults FIRST --- 
// -- UPDATED renderBacktestResults --
function renderBacktestResults(results) {
  let tableHTML = `
    [[style]]
      .backtest-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }
      .backtest-table th, .backtest-table td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: center;
      }
      .backtest-table th {
        background-color: #3498db;
        color: #fff;
      }
    [[/style]]
    [[table class="backtest-table"]]
      [[thead]]
        [[tr]]
          [[th]]Draw Date[[/th]]
          [[th]]Actual Main Numbers[[/th]]
          [[th]]Actual Extra Ball(s)[[/th]]
          [[th]]Predicted Main Numbers (Top 20)[[/th]]
          [[th]]Predicted Extra Ball(s)[[/th]]
          [[th]]Main Match Count[[/th]]
          [[th]]Extra Match Count[[/th]]
        [[/tr]]
      [[/thead]]
      [[tbody]]
  `;

  results.forEach(r => {
    tableHTML += `
      [[tr]]
        [[td]]${r.date}[[/td]]
        [[td]]${r.actualMain}[[/td]]
        [[td]]${r.actualExtra.length ? r.actualExtra.join(', ') : '–'}[[/td]]
        [[td]]${r.predictedMain}[[/td]]
        [[td]]${r.predictedExtra.length ? r.predictedExtra.join(', ') : '–'}[[/td]]
        [[td]]${r.mainMatchCount}[[/td]]
        [[td]]${r.extraMatchCount}[[/td]]
      [[/tr]]
    `;
  });

   tableHTML += `
      [[/tbody]]
    [[/table]]
  `;

  // SKAI proper scoring summary (if present)
  if (results && results.skaiSummary) {
    const s = results.skaiSummary;

    tableHTML += `
      [[div style="margin-top:12px; padding:10px; border:1px solid #ccc; border-radius:6px; text-align:left;"]]
        [[div style="font-weight:700; margin-bottom:6px;"]]SKAI Backtest Proper-Scoring Summary[[/div]]
        [[div]]Steps: ${s.steps}[[/div]]
        [[div]]Main: Avg Expected Mass (in picks): ${Number(s.avgExpectedMassMain).toFixed(4)}[[/div]]
        [[div]]Main: Avg Brier (lower better): ${Number(s.avgBrierMain).toFixed(6)}[[/div]]
        [[div]]Main: Avg LogLoss (lower better): ${Number(s.avgLogLossMain).toFixed(6)}[[/div]]
        [[div]]Extra: Avg Expected Mass (in picks): ${Number(s.avgExpectedMassExtra).toFixed(4)}[[/div]]
        [[div]]Extra: Avg Brier (lower better): ${Number(s.avgBrierExtra).toFixed(6)}[[/div]]
        [[div]]Extra: Avg LogLoss (lower better): ${Number(s.avgLogLossExtra).toFixed(6)}[[/div]]
      [[/div]]
    `;
  }

  return tableHTML;
}
      // --- END: renderBacktestResults ---



      // Prevent any accidental form submission
      const predictionForm = document.getElementById('predictionForm');
      if (predictionForm) {
        predictionForm.addEventListener('submit', function(e) {
          e.preventDefault();
        });
      }
      
      var draws = <?php echo json_encode($draws); ?>;
      console.log("All Draws:", draws);
      // Lottery parameters
      const mainNumbersMax = <?php echo $mainNumbersMax; ?>;
      const pickSize = <?php echo $pickSize; ?>;
      const hasExtraBall = <?php echo $hasExtraBall ? 'true' : 'false'; ?>;
      const numExtraBalls   = <?php echo $numExtraBalls; ?>;  
      const extraBallMax = <?php echo $extraBallMax !== null ? $extraBallMax : 'null'; ?>;
      const topExtraSuggestions = 5;
        
        
      // Normalize data function
      function normalizeData(data) {
        return data.map(arr => arr.map((num, index) => {
          if (index < pickSize) {
            return num / mainNumbersMax;
          } else if (hasExtraBall && extraBallMax !== null) {
            return num / extraBallMax;
          } else {
            return num;
          }
        }));
      }
      
      const predictionDiv = document.getElementById('prediction');
      const loadingDiv = document.getElementById('loading');
      const numberBreakdownDiv = document.getElementById('numberBreakdown');
      const progressBar = document.getElementById('progressBar');
      const progressMessage = document.getElementById('progressMessage');
      const startButton = document.getElementById('startPrediction');
      const countdownDiv = document.getElementById('countdown');
      const funMessageDiv = document.getElementById('funMessage');
      const predictedNumbersDiv = document.getElementById('predictedNumbers');
      const numberBreakdownTableDiv = document.getElementById('numberBreakdownTable');
      
      const backtestNoticeDiv = document.getElementById('backtestNotice');
      const backtestResultsDiv = document.getElementById('backtestResults');
      const backtestProgressContainer = document.getElementById('backtestProgressContainer');
      const backtestProgressBar = document.getElementById('backtestProgressBar');
      const epochsInput = document.getElementById('epochs');
      const batchSizeInput = document.getElementById('batchSize');
      const dropoutRateInput = document.getElementById('dropoutRate');
      const latestDrawDateInput = document.getElementById('latestDrawDate');
      const learningRateInput = document.getElementById('learningRate');
      const activationFunctionInput = document.getElementById('activationFunction');
      const hiddenLayersInput = document.getElementById('hiddenLayers');
      const enableBacktestCheckbox = document.getElementById('enableBacktest');

      // Live ? (recency decay) readout
      const recencyDecayInput = document.getElementById('recencyDecay');
      const recencyDecayLambdaReadout = document.getElementById('recencyDecayLambdaReadout');

      // PATCH 7B-1: Live SKAI blend readout (AI ? vs Skip 1-?, plus ß and T)
      const skaiBlendReadoutEl = document.getElementById('skaiBlendReadout');

      function skaiFmt2(n) {
        var x = parseFloat(n);
        if (!isFinite(x)) { x = 0; }
        return x.toFixed(2);
      }

      function skaiClamp01(x) {
        var n = parseFloat(x);
        if (!isFinite(n)) { n = 0; }
        return Math.max(0, Math.min(1, n));
      }

      function skaiUpdateBlendReadout(modeKey, lambda, beta, tempT) {
        if (!skaiBlendReadoutEl) { return; }
        var lam = skaiClamp01(lambda);
        var skip = 1 - lam;
        skaiBlendReadoutEl.textContent =
          'Mode: ' + String(modeKey || 'balanced') +
          ' • AI ?: ' + skaiFmt2(lam) +
          ' • Skip: ' + skaiFmt2(skip) +
          ' • ß: ' + skaiFmt2(beta) +
          ' • T: ' + skaiFmt2(tempT);
      }

      function formatLambda(val) {
        var n = parseFloat(val);
        if (isNaN(n)) { n = 1.0; }
        n = Math.max(0, Math.min(1, n));
        return n.toFixed(2);
      }

      function syncLambdaReadout() {
        if (!recencyDecayInput || !recencyDecayLambdaReadout) {
          return;
        }
        recencyDecayLambdaReadout.textContent = '? = ' + formatLambda(recencyDecayInput.value);
      }

      // Initialize and keep in sync while editing
      if (recencyDecayInput) {
        recencyDecayInput.addEventListener('input', syncLambdaReadout);
        recencyDecayInput.addEventListener('change', syncLambdaReadout);
      }
      syncLambdaReadout();

      // Guard so a missing checkbox can't break the whole script (and kill the progress bar)
      if (enableBacktestCheckbox) {
        enableBacktestCheckbox.addEventListener('change', function() {
          const numDrawsSelect = document.getElementById('numDrawsBacktest');
          if (numDrawsSelect) {
            numDrawsSelect.disabled = !this.checked;
          }
        });
      }

  // ---- SKAI Mode Presets (Option B – game-aware) ----
  var skaiGameType = '<?php echo $skaiGameType; ?>'; // 'jackpot', 'pick5', 'daily', 'multiExtra'

  // Capture base values from JSON config as "Balanced" anchors
  function safeNumber(val, fallback) {
    var n = parseFloat(val);
    return isNaN(n) ? fallback : n;
  }

  var baseEpochs      = safeNumber(epochsInput && epochsInput.value,      200);
  var baseBatch       = safeNumber(batchSizeInput && batchSizeInput.value,32);
  var baseDropout     = safeNumber(dropoutRateInput && dropoutRateInput.value,0.2);
  var baseLR          = safeNumber(learningRateInput && learningRateInput.value,0.001);
  var baseLayers      = safeNumber(hiddenLayersInput && hiddenLayersInput.value,2);
  var baseRecency     = safeNumber(document.getElementById('recencyDecay') && document.getElementById('recencyDecay').value,1.0);

  function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val));
  }

  function buildPresetsForGameType(gameType) {
    var presets = {};

    if (gameType === 'daily') {
      // Pick 3 / Pick 4 – very fast-moving patterns
      presets.balanced = {
        epochs:      clamp(baseEpochs, 50, 500),
        batch:       clamp(baseBatch, 16, 128),
        dropout:     clamp(baseDropout, 0.15, 0.35),
        lr:          clamp(baseLR, 0.0005, 0.01),
        recency:     clamp(baseRecency || 0.90, 0.70, 1.0),
        layers:      clamp(baseLayers, 1, 3)
      };
      presets.explorative = {
        epochs:      clamp(baseEpochs * 1.3, 100, 800),
        batch:       clamp(baseBatch, 16, 128),
        dropout:     clamp(baseDropout - 0.05, 0.05, 0.3),
        lr:          clamp(baseLR * 1.3, 0.0005, 0.02),
        recency:     0.75,
        layers:      clamp(baseLayers + 1, 2, 4)
      };
      presets.conservative = {
        epochs:      clamp(baseEpochs * 0.7, 30, 400),
        batch:       clamp(baseBatch, 16, 128),
        dropout:     clamp(baseDropout + 0.05, 0.2, 0.5),
        lr:          clamp(baseLR * 0.7, 0.0001, 0.005),
        recency:     0.98,
        layers:      clamp(baseLayers, 1, 3)
      };
    } else if (gameType === 'pick5') {
      // 5-number games without extra ball
      presets.balanced = {
        epochs:      clamp(baseEpochs, 100, 800),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout, 0.15, 0.35),
        lr:          clamp(baseLR, 0.0005, 0.01),
        recency:     clamp(baseRecency || 0.94, 0.80, 1.0),
        layers:      clamp(baseLayers, 2, 4)
      };
      presets.explorative = {
        epochs:      clamp(baseEpochs * 1.3, 150, 1200),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout - 0.05, 0.1, 0.3),
        lr:          clamp(baseLR * 1.3, 0.0005, 0.02),
        recency:     0.85,
        layers:      clamp(baseLayers + 1, 3, 5)
      };
      presets.conservative = {
        epochs:      clamp(baseEpochs * 0.75, 80, 600),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout + 0.05, 0.2, 0.45),
        lr:          clamp(baseLR * 0.7, 0.0001, 0.005),
        recency:     0.97,
        layers:      clamp(baseLayers, 2, 4)
      };
    } else if (gameType === 'multiExtra') {
      // EuroMillions-style (two extra balls)
      presets.balanced = {
        epochs:      clamp(baseEpochs, 200, 1000),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout, 0.15, 0.35),
        lr:          clamp(baseLR, 0.0003, 0.008),
        recency:     clamp(baseRecency || 0.93, 0.80, 1.0),
        layers:      clamp(baseLayers, 2, 5)
      };
      presets.explorative = {
        epochs:      clamp(baseEpochs * 1.4, 300, 1500),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout - 0.05, 0.1, 0.3),
        lr:          clamp(baseLR * 1.2, 0.0004, 0.012),
        recency:     0.86,
        layers:      clamp(baseLayers + 1, 3, 6)
      };
      presets.conservative = {
        epochs:      clamp(baseEpochs * 0.7, 120, 900),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout + 0.05, 0.2, 0.45),
        lr:          clamp(baseLR * 0.7, 0.0001, 0.005),
        recency:     0.97,
        layers:      clamp(baseLayers, 2, 5)
      };
    } else {
      // Jackpot-style (Powerball, Mega Millions, large pick-6 etc.)
      presets.balanced = {
        epochs:      clamp(baseEpochs, 200, 1200),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout, 0.15, 0.35),
        lr:          clamp(baseLR, 0.0003, 0.008),
        recency:     clamp(baseRecency || 0.95, 0.85, 1.0),
        layers:      clamp(baseLayers, 2, 5)
      };
      presets.explorative = {
        epochs:      clamp(baseEpochs * 1.4, 300, 1600),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout - 0.05, 0.1, 0.3),
        lr:          clamp(baseLR * 1.2, 0.0004, 0.012),
        recency:     0.88,
        layers:      clamp(baseLayers + 1, 3, 6)
      };
      presets.conservative = {
        epochs:      clamp(baseEpochs * 0.7, 150, 900),
        batch:       clamp(baseBatch, 32, 256),
        dropout:     clamp(baseDropout + 0.05, 0.2, 0.45),
        lr:          clamp(baseLR * 0.7, 0.0001, 0.005),
        recency:     0.98,
        layers:      clamp(baseLayers, 2, 5)
      };
    }

    return presets;
  }

  var skaiPresets = buildPresetsForGameType(skaiGameType);
  var modeButtons = document.querySelectorAll('.skai-mode-btn');
  var modeDesc    = document.getElementById('skaiModeDescription');

function describeMode(modeKey) {
  // New SKAI blend modes (game-agnostic explanations)
  if (modeKey === 'mixed') {
    return 'Mixed mode dynamically blends AI-driven probabilities with Skip & Hit behavior. When both signals agree, SKAI leans confidently; when they diverge, it adapts conservatively to reduce instability.';
  }

  if (modeKey === 'ai-forward') {
    return 'AI-forward mode prioritizes the neural network’s learned probability structure, relying less on Skip patterns and more on learned sequence behavior.';
  }

  if (modeKey === 'skip-dominant') {
    return 'Skip-dominant mode places stronger emphasis on Skip & Hit dynamics, favoring numbers that statistical gap behavior suggests may be due.';
  }

  // Original per-game-type messaging for Balanced / Explorative / Conservative
  var text = '';

  if (skaiGameType === 'daily') {
    if (modeKey === 'balanced') {
      text = 'Balanced mode is tuned for daily games, mixing long-term behavior with recent movement for steady play.';
    } else if (modeKey === 'explorative') {
      text = 'Explorative mode leans harder into recent shifts for daily games, intentionally exploring more variation.';
    } else {
      text = 'Conservative mode stays closer to stable daily-game tendencies, avoiding sharp swings from recent draws.';
    }
  } else if (skaiGameType === 'pick5') {
    if (modeKey === 'balanced') {
      text = 'Balanced mode is tuned for steady Pick 5 play, mixing long-term history with recent movements.';
    } else if (modeKey === 'explorative') {
      text = 'Explorative mode looks harder at recent gaps and co-occurrences in Pick 5, to highlight evolving patterns.';
    } else {
      text = 'Conservative mode keeps Pick 5 analysis closer to long-term averages, moderating swings from recent draws.';
    }
  } else if (skaiGameType === 'multiExtra') {
    if (modeKey === 'balanced') {
      text = 'Balanced mode is tuned for multi-extra games, combining long-term structure with controlled recency bias.';
    } else if (modeKey === 'explorative') {
      text = 'Explorative mode leans into short-term movement for multi-extra games, exploring more aggressively while staying coherent.';
    } else {
      text = 'Conservative mode emphasizes stable long-term behavior for multi-extra games, reducing volatility from recent draws.';
    }
  } else {
    // Jackpot-style default
    if (modeKey === 'balanced') {
      text = 'Balanced mode uses steady, well-rounded settings designed for everyday play.';
    } else if (modeKey === 'explorative') {
      text = 'Explorative mode chases recent patterns more aggressively and allows greater variation.';
    } else {
      text = 'Conservative mode stays closer to long-term historical behavior and avoids sharp swings.';
    }
  }

  return text;
}

  function applyPreset(modeKey) {
    // Fallback: new SKAI blend modes (mixed / ai-forward / skip-dominant) should still
    // apply a reasonable training preset rather than doing nothing.
    var preset = skaiPresets[modeKey] || skaiPresets.balanced;
    if (!preset) {
      return;
    }

    if (epochsInput)         { epochsInput.value = Math.round(preset.epochs); }
    if (batchSizeInput)      { batchSizeInput.value = Math.round(preset.batch); }
    if (dropoutRateInput)    { dropoutRateInput.value = preset.dropout.toFixed(2); }
    if (learningRateInput)   { learningRateInput.value = preset.lr.toFixed(5); }
    if (hiddenLayersInput)   { hiddenLayersInput.value = Math.round(preset.layers); }
    var recencyInput = document.getElementById('recencyDecay');
    if (recencyInput)        { recencyInput.value = preset.recency.toFixed(2); }

    if (modeDesc) {
      modeDesc.textContent = describeMode(modeKey);
    }
  }

  if (modeButtons && modeButtons.length) {
    for (var i = 0; i < modeButtons.length; i++) {
      modeButtons[i].addEventListener('click', function (e) {
        var chosen = this.getAttribute('data-skai-mode') || 'balanced';

        for (var j = 0; j < modeButtons.length; j++) {
          var pressed = modeButtons[j].getAttribute('data-skai-mode') === chosen;
          modeButtons[j].setAttribute('aria-pressed', pressed ? 'true' : 'false');
        }

                applyPreset(chosen);

        // PATCH 7B-2: update blend readout immediately on mode change
        var betaNow = (typeof getSkaiSkipBeta === 'function') ? getSkaiSkipBeta(chosen) : 2.0;
        var tNow = (typeof skaiGetStoredTemp === 'function') ? skaiGetStoredTemp(chosen) : 1.0;

        // Before a prediction runs, Mixed has no agreement info yet; show a sensible baseline.
        var lamNow = (chosen === 'mixed')
          ? 0.65
          : ((typeof getSkaiBlendLambda === 'function') ? getSkaiBlendLambda(chosen) : 0.65);

        skaiUpdateBlendReadout(chosen, lamNow, betaNow, tNow);

      });
    }

    // Ensure Balanced preset is applied on load so inputs match explanatory text
        applyPreset('balanced');

    // PATCH 7B-2 (load): initialize blend readout to match the default mode
    if (typeof skaiUpdateBlendReadout === 'function') {
      var betaInit = (typeof getSkaiSkipBeta === 'function') ? getSkaiSkipBeta('balanced') : 2.0;
      var tInit = (typeof skaiGetStoredTemp === 'function') ? skaiGetStoredTemp('balanced') : 1.0;
      skaiUpdateBlendReadout('balanced', 0.65, betaInit, tInit);
    }

  }
  // ---- END SKAI Mode Presets ----



      /* PATCH: Disabled legacy SKAI preset system (duplicate listeners / conflicting behavior).
         The active system is the newer:
         // ---- SKAI Mode Presets (Option B – game-aware) ----
         above this block.
      // === SKAI Mode Presets (Balanced / Explorative / Conservative) ===
      var skaiModeButtons = document.querySelectorAll('.skai-mode-btn');
      var skaiModeDescription = document.getElementById('skaiModeDescription');

      // Base values from PHP config (per game)
      var baseEpochs        = <?php echo (int) $epochs; ?>;
      var baseBatchSize     = <?php echo (int) $batchSize; ?>;
      var baseDropout       = <?php echo (float) $dropoutRate; ?>;
      var baseLearningRate  = <?php echo (float) $learningRate; ?>;
      var baseHiddenLayers  = <?php echo (int) $hiddenLayers; ?>;
      var baseRecencyDecay  = <?php
        $rd = isset($gameConfig['recencyDecay']) ? (float) $gameConfig['recencyDecay'] : 1.0;
        echo $rd;
      ?>;

      // Helper to clamp values into safe ranges
      function clampValue(val, min, max) {
        if (val < min) { return min; }
        if (val > max) { return max; }
        return val;
      }

      function applySkaiPreset(mode) {
        var e = baseEpochs;
        var b = baseBatchSize;
        var d = baseDropout;
        var lr = baseLearningRate;
        var h = baseHiddenLayers;
        var rd = baseRecencyDecay;
        var desc = '';

        if (mode === 'balanced') {
          // Use defaults as-is
          desc = 'Balanced mode uses LottoExpert’s recommended defaults – a steady choice for everyday play that balances learning from recent draws with long-term behaviour.';
        } else if (mode === 'explorative') {
          // Lean harder into patterns and recent data
          e = Math.round(baseEpochs * 1.3);
          b = baseBatchSize; // keep batch stable
          d = clampValue(baseDropout - 0.1, 0.1, 0.5);
          lr = baseLearningRate * 1.2;
          rd = 0.85; // more weight on recent draws
          desc = 'Explorative mode leans into recent patterns more aggressively – more learning steps, slightly lower dropout, and a stronger focus on what has happened lately.';
        } else if (mode === 'conservative') {
          // Stay closer to long-term behaviour
          e = Math.max(5, Math.round(baseEpochs * 0.7));
          b = baseBatchSize;
          d = clampValue(baseDropout + 0.1, 0.1, 0.6);
          lr = baseLearningRate * 0.8;
          rd = 0.98; // almost equal weight over time
          desc = 'Conservative mode stays closer to long-term behaviour – fewer training passes, slightly higher dropout, and recency decay close to 1.0 so older draws still carry strong weight.';
        }

        // Apply values to the visible inputs
        if (epochsInput)        { epochsInput.value = e; }
        if (batchSizeInput)     { batchSizeInput.value = b; }
        if (dropoutRateInput)   { dropoutRateInput.value = d; }
        if (learningRateInput)  { learningRateInput.value = lr; }
        if (hiddenLayersInput)  { hiddenLayersInput.value = h; }
        var rdInput = document.getElementById('recencyDecay');
        if (rdInput)            { rdInput.value = rd; }

        if (skaiModeDescription && desc) {
          skaiModeDescription.textContent = desc;
        }
      }

      if (skaiModeButtons && skaiModeButtons.length) {
        for (var i = 0; i < skaiModeButtons.length; i++) {
          skaiModeButtons[i].addEventListener('click', function () {
            var mode = this.getAttribute('data-skai-mode');

            // Update active state
            for (var j = 0; j < skaiModeButtons.length; j++) {
              skaiModeButtons[j].classList.remove('is-active');
            }
            this.classList.add('is-active');

            applySkaiPreset(mode);
          });
        }

        // Ensure Balanced is applied on first load so inputs reflect the current mode
        applySkaiPreset('balanced');
      }
      */ // PATCH: end disabled legacy SKAI preset system
      
      const epochValue = document.getElementById('epochValue');
      const batchSizeValue = document.getElementById('batchSizeValue');
      const dropoutRateValue = document.getElementById('dropoutRateValue');
      const latestDrawDateValue = document.getElementById('latestDrawDateValue');
      const predictionDateValue = document.getElementById('predictionDateValue');
      const learningRateValue = document.getElementById('learningRateValue');
      const activationFunctionValue = document.getElementById('activationFunctionValue');
      const hiddenLayersValue = document.getElementById('hiddenLayersValue');
      const recencyDecayValue     = document.getElementById('recencyDecayValue');
const funMessages = [
  "Analyzing past draws for patterns…",
  "Measuring how often each number appears over time…",
  "Checking how recent draws differ from older ones…",
  "Updating probability estimates based on your settings…",
  "Reviewing model accuracy on past draws…",
  "Balancing recent trends with long-term history…",
  "Refining the model to reduce overfitting…",
  "Preparing your probability-based number rankings…"
];
      
      const messages = [
        "System Status: Loading historical lottery data...",
        "System Status: Initializing AI model...",
        "System Status: Processing training data...",
        "System Status: Training in progress...",
        "System Status: Adjusting neural networks...",
        "System Status: Optimizing parameters...",
        "System Status: Generating Analysis...",
        "System Status: Finalizing results...",
        "System Status: Analysis complete!"
      ];
      
      let startTime;
      let epochStartTime;
      let smoothedTimePerEpoch = 0;
      const smoothingFactor = 0.1;
      const funMessageInterval = 5000;
      

// --- BEGIN FIXED BACKTEST FUNCTIONS ---

// Utility: build a tensor of recency-decay weights
function buildSampleWeightTensor(numSamples, decay) {
  const weights = Array.from({length: numSamples}, (_, i) =>
    Math.pow(decay, (numSamples - 1) - i)
  );
  return tf.tensor1d(weights);
}

// Global skip influence factor (0.0–1.0).
// Higher values make Skip & Hit bias stronger in the final probabilities.
// You can tweak this later (e.g., 0.2 = softer, 0.5 = stronger).
const SKIP_ALPHA = 0.3;

// --- SKAI probabilistic blending helpers (math-correct ensemble) ---
// NOTE: SKIP_ALPHA remains for backwards-compatibility, but SKAI now uses a coherent expert blend.
var SKAI_EPS               = 1e-9;
var SKAI_SKIP_BETA_DEFAULT = 2.0;  // controls how strongly skipScores separate numbers (hoist-safe)
var SKAI_BLEND_DEFAULT     = 0.65; // Balanced-mode default AI weight ? (hoist-safe)

function getSelectedSkaiMode() {
  const btn = document.querySelector('.skai-mode-btn[aria-pressed="true"]');
  return (btn && btn.getAttribute('data-skai-mode')) ? btn.getAttribute('data-skai-mode') : 'balanced';
}

// Mode ? ? (AI weight). Higher ? = more AI-forward.
function getSkaiBlendLambda(modeKey) {
  if (modeKey === 'ai-forward')     { return 0.90; }
  if (modeKey === 'conservative')   { return 0.80; }
  if (modeKey === 'explorative')    { return 0.45; }
  if (modeKey === 'skip-dominant')  { return 0.35; }
  // mixed is adaptive; computed from ai/skip distributions (see getSkaiLambda below)
  if (modeKey === 'mixed')          { return NaN; }
  // balanced / unknown
  return SKAI_BLEND_DEFAULT;
}

// Jensen–Shannon divergence for two discrete distributions (bounded, symmetric, stable).
function skaiJSDivergence(p, q) {
  const n = Math.min(p.length, q.length);
  let js = 0;
  for (let i = 0; i < n; i++) {
    const pi = Math.max(SKAI_EPS, p[i]);
    const qi = Math.max(SKAI_EPS, q[i]);
    const mi = 0.5 * (pi + qi);
    js += 0.5 * (pi * Math.log(pi / mi) + qi * Math.log(qi / mi));
  }
  // Natural log units; bounded in [0, ln(2)]
  return js;
}

// Mixed mode: ? adapts to how much AI and Skip agree.
// - If they agree (low JSD), lean AI-forward more.
// - If they disagree (high JSD), pull ? toward 0.5 to avoid over-committing.
function skaiAdaptiveLambdaMixed(aiNorm, skipProb) {
  const js = skaiJSDivergence(aiNorm, skipProb);
  const jsMax = Math.log(2); // theoretical maximum
  const agree = 1 - Math.min(1, js / jsMax); // 1=agree, 0=disagree

  // Map agreement into a safe ? band for Mixed:
  // - High agreement ? ? up to ~0.80
  // - Low agreement  ? ? down to ~0.50
  const lambda = 0.50 + (0.30 * agree);

  // Clamp defensively
  return Math.max(0.35, Math.min(0.90, lambda));
}

// Unified ? getter: fixed for other modes; adaptive for Mixed.
function getSkaiLambda(modeKey, aiNorm, skipProb) {
  if (modeKey === 'mixed') {
    return skaiAdaptiveLambdaMixed(aiNorm, skipProb);
  }
  const lam = getSkaiBlendLambda(modeKey);
  return (typeof lam === 'number' && isFinite(lam)) ? lam : SKAI_BLEND_DEFAULT;
}

// Mode-aware skip separation (beta). Higher beta makes Skip expert “sharper”.
function getSkaiSkipBeta(modeKey) {
  if (modeKey === 'skip-dominant') { return 3.0; }
  if (modeKey === 'explorative')   { return 2.5; }
  if (modeKey === 'conservative')  { return 1.6; }
  if (modeKey === 'ai-forward')    { return 1.6; }
  if (modeKey === 'mixed')         { return 2.2; }
  return SKAI_SKIP_BETA_DEFAULT; // balanced
}

// Temperature for exploration sampling (t >= 1). t=1 means no flattening.
function getSkaiExploreTau(modeKey) {
  if (modeKey === 'explorative') { return 1.8; }
  if (modeKey === 'mixed')       { return 1.4; }
  return 1.0;
}

// How many picks should be “explore sampled” instead of strict top-k.
function getSkaiExploreCount(modeKey, pickSize) {
  if (modeKey === 'explorative') { return Math.max(1, Math.floor(pickSize * 0.30)); }
  if (modeKey === 'mixed')       { return Math.max(1, Math.floor(pickSize * 0.20)); }
  return 0;
}

// Build a tempered mass (flattened) for sampling: p^(1/t), normalized.
function skaiTemperedMass(probMass, tau) {
  if (!tau || tau <= 1) {
    return normalizePositive(probMass);
  }
  const raw = new Array(probMass.length);
  const inv = 1 / tau;
  for (let i = 0; i < probMass.length; i++) {
    raw[i] = Math.pow(Math.max(SKAI_EPS, probMass[i]), inv);
  }
  return normalizePositive(raw);
}

// Weighted sampling without replacement from a probability mass.
function skaiSampleWithoutReplacement(probMass, count) {
  const picks = [];
  const available = probMass.slice(0);

  for (let k = 0; k < count; k++) {
    // Build CDF
    let sum = 0;
    for (let i = 0; i < available.length; i++) {
      sum += Math.max(0, available[i]);
    }
    if (sum <= 0) {
      break;
    }

    let r = Math.random() * sum;
    let chosen = -1;
    for (let i = 0; i < available.length; i++) {
      r -= Math.max(0, available[i]);
      if (r <= 0) { chosen = i; break; }
    }
    if (chosen < 0) { break; }

    picks.push(chosen);
    available[chosen] = 0; // remove
  }

  return picks;
}

// Select final picks: exploit top-(pickSize-exploreCount), explore sample the rest.
function skaiSelectPicksFromMass(probMass, pickSize, modeKey) {
  const exploreCount = getSkaiExploreCount(modeKey, pickSize);
  const tau = getSkaiExploreTau(modeKey);

  const indices = [];
  // Exploit indices by sorting
  const ranked = probMass.map((p, i) => ({ i, p })).sort((a, b) => b.p - a.p);

  const exploitCount = Math.max(0, pickSize - exploreCount);
  for (let k = 0; k < exploitCount && k < ranked.length; k++) {
    indices.push(ranked[k].i);
  }

  if (exploreCount > 0) {
    // Build remaining mass excluding already-picked exploit indices
    const remaining = probMass.slice(0);
    for (let k = 0; k < indices.length; k++) {
      remaining[indices[k]] = 0;
    }

    const tempered = skaiTemperedMass(remaining, tau);
    const sampled = skaiSampleWithoutReplacement(tempered, exploreCount);
    for (let k = 0; k < sampled.length; k++) {
      indices.push(sampled[k]);
    }
  }

 // Return sorted numeric values (1-based numbers) for stable display (dedup defensive)
  const uniq = Array.from(new Set(indices)).map(i => i + 1);
  return uniq.sort((a, b) => a - b);}

// Normalize a positive vector into sum-to-1 mass (with epsilon floor).
function normalizePositive(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    const v = (typeof arr[i] === 'number' && isFinite(arr[i])) ? Math.max(SKAI_EPS, arr[i]) : SKAI_EPS;
    sum += v;
  }
  const out = new Array(arr.length);
  const denom = (sum > 0) ? sum : (arr.length * SKAI_EPS);
  for (let i = 0; i < arr.length; i++) {
    const v = (typeof arr[i] === 'number' && isFinite(arr[i])) ? Math.max(SKAI_EPS, arr[i]) : SKAI_EPS;
    out[i] = v / denom;
  }
  return out;
}

// Turn skipScores (0..1) into a proper expert distribution using a softmax-like transform.
function buildSkipExpertProbs(skipScores, beta) {
  const raw = new Array(skipScores.length);
  for (let i = 0; i < skipScores.length; i++) {
    const u = (typeof skipScores[i] === 'number' && isFinite(skipScores[i])) ? skipScores[i] : 0;
    // center at 0.5 to reduce runaway bias; beta controls separation
    raw[i] = Math.exp(beta * (u - 0.5));
  }
  return normalizePositive(raw);
}

// Log-opinion pool (geometric mixture): p ? ai^? * skip^(1-?)
function logOpinionPool(aiProbs, skipProbs, lambda) {
  const out = new Array(aiProbs.length);
  for (let i = 0; i < aiProbs.length; i++) {
    const a = Math.max(SKAI_EPS, aiProbs[i]);
    const s = Math.max(SKAI_EPS, skipProbs[i]);
    out[i] = Math.exp(lambda * Math.log(a) + (1 - lambda) * Math.log(s));
  }
  return normalizePositive(out);
}
 // --- END SKAI probabilistic blending helpers ---

// --- SKAI backtest proper scoring rules (math-correct evaluation) ---
function skaiClipProb(p) {
  if (typeof p !== 'number' || !isFinite(p)) { return SKAI_EPS; }
  return Math.min(1 - SKAI_EPS, Math.max(SKAI_EPS, p));
}

function skaiBrierScore(probMass, actualSet, maxVal) {
  // probMass: array length maxVal, sum-to-1
  // actualSet: Set of winning numbers in 1..maxVal
  let sum = 0;
  for (let i = 0; i < maxVal; i++) {
    const p = skaiClipProb(probMass[i]);
    const y = actualSet.has(i + 1) ? 1 : 0;
    const d = p - y;
    sum += d * d;
  }
  return sum / maxVal;
}

function skaiLogLoss(probMass, actualSet, maxVal) {
  // Strictly proper for Bernoulli marginals; clipped to avoid -Inf
  let sum = 0;
  for (let i = 0; i < maxVal; i++) {
    const p = skaiClipProb(probMass[i]);
    const y = actualSet.has(i + 1) ? 1 : 0;
    sum += y ? -Math.log(p) : -Math.log(1 - p);
  }
  return sum / maxVal;
}

function skaiExpectedMassInPicks(probMass, picks) {
  // picks: array of numbers (1..max)
  let s = 0;
  for (let i = 0; i < picks.length; i++) {
    const idx = picks[i] - 1;
    if (idx >= 0 && idx < probMass.length) {
      s += skaiClipProb(probMass[idx]);
    }
  }
  return s;
}
// --- END SKAI backtest proper scoring rules ---
// Compute per-draw Skip feature vectors for a chronological series of draws.
// drawsNumbers: [ [n1, n2, ...], ... ] in OLDEST ? NEWEST order.
// For each draw t, we compute skipVec[t][k] = draws since number (k+1) last appeared BEFORE draw t.
function computeSkipFeatureSeries(drawsNumbers, pickSize, mainNumbersMax) {
  const lastHitIndex   = new Array(mainNumbersMax).fill(null);
  const skipsPerStep   = [];

  for (let t = 0; t < drawsNumbers.length; t++) {
    const skipVec = new Array(mainNumbersMax).fill(0);

    // For each number, how long since last seen?
    for (let k = 0; k < mainNumbersMax; k++) {
      const last = lastHitIndex[k];
      // If we've never seen it, treat skip as t (all previous draws missed it).
      const skip = (last === null) ? t : (t - last - 1);
      skipVec[k] = skip;
    }

    // Now update lastHitIndex using the CURRENT draw's main numbers.
    const draw = drawsNumbers[t];
    for (let j = 0; j < pickSize; j++) {
      const n = draw[j];
      if (n >= 1 && n <= mainNumbersMax) {
        lastHitIndex[n - 1] = t;
      }
    }

    skipsPerStep.push(skipVec);
  }

  // Normalize skips to 0..1 so they play nicely with normalized inputs.
  let maxSkip = 0;
  for (let t = 0; t < skipsPerStep.length; t++) {
    const vec = skipsPerStep[t];
    for (let i = 0; i < vec.length; i++) {
      if (vec[i] > maxSkip) {
        maxSkip = vec[i];
      }
    }
  }

  if (maxSkip > 0) {
    for (let t = 0; t < skipsPerStep.length; t++) {
      const vec = skipsPerStep[t];
      for (let i = 0; i < vec.length; i++) {
        vec[i] = vec[i] / maxSkip;
      }
    }
  }

  return skipsPerStep;
}

// Compute per-number Skip scores (0..1) from a DESC list of draws (most recent first).
// This is a thin wrapper around computeSkipFeatureSeries so older code that calls
// computeSkipScores(...) continues to work.
function computeSkipScores(drawsDesc, pickSize, mainNumbersMax) {
  // Convert DESC draws into ASC array of numbers for computeSkipFeatureSeries.
  const drawsAscNumbers = [...drawsDesc].slice().reverse().map(d => d.numbers);
  if (!drawsAscNumbers.length) {
    return new Array(mainNumbersMax).fill(0);
  }

  const skipSeries = computeSkipFeatureSeries(drawsAscNumbers, pickSize, mainNumbersMax);
  const latestVec  = skipSeries[skipSeries.length - 1] || [];
  const result     = new Array(mainNumbersMax).fill(0);

  for (let i = 0; i < mainNumbersMax; i++) {
    result[i] = (typeof latestVec[i] === 'number') ? latestVec[i] : 0;
  }

  return result;
}

async function trainModelForBacktest(trainingDraws, settings, onEpochEndCallback) {
  const pickSize       = settings.PICK_SIZE;
  const mainNumbersMax = settings.MAIN_MAX;
  const extraBallMax   = settings.EXTRA_MAX;
  const hasExtraBall   = settings.HAS_EXTRA;

  // 1) normalize inputs
  const drawsNumbers = trainingDraws.map(d => d.numbers);
  const normalized   = drawsNumbers.map(arr =>
    arr.map((n, i) =>
      i < pickSize
        ? n / mainNumbersMax
        : (hasExtraBall ? n / extraBallMax : n)
    )
  );

  // 1b) compute Skip feature series (per draw, per main number)
  const skipFeatureSeries = computeSkipFeatureSeries(drawsNumbers, pickSize, mainNumbersMax);

  // 2) build X and Y arrays
  const xs = [], ys_main = [], ys_extra = [];
  for (let i = 0; i < normalized.length - 1; i++) {
    const baseInput    = normalized[i];
    const skipFeatures = skipFeatureSeries[i];
    const inputVec     = baseInput.concat(skipFeatures);
    xs.push(inputVec);

    const nextNums = drawsNumbers[i + 1];

    // Y for main
    const mainVec = new Array(mainNumbersMax).fill(0);
    nextNums.slice(0, pickSize).forEach(n => mainVec[n - 1] = 1);
    ys_main.push(mainVec);

    // Y for extra
    if (hasExtraBall) {
      const extraVec = new Array(extraBallMax).fill(0);
      extraVec[nextNums[pickSize] - 1] = 1;
      ys_extra.push(extraVec);
    }
  }

  // 3) create tensors
  const xsTensor     = tf.tensor2d(xs);
  const ysMainTensor = tf.tensor2d(ys_main);
  let ysExtraTensor;
  if (hasExtraBall) {
    ysExtraTensor = tf.tensor2d(ys_extra);
  }

  // 4) recency-decay weights
  const sampleWeightTensor = buildSampleWeightTensor(xs.length, settings.RECENCY_DECAY);

  // 5) build the model
  const input = tf.input({ shape: [xs[0].length] });
  let x = tf.layers.dense({ units: 128, activation: settings.ACTIVATION_FUNCTION }).apply(input);
  x = tf.layers.dropout({ rate: settings.DROPOUT_RATE }).apply(x);
  for (let i = 0; i < settings.HIDDEN_LAYERS; i++) {
    x = tf.layers.dense({ units: 64, activation: settings.ACTIVATION_FUNCTION }).apply(x);
    x = tf.layers.dropout({ rate: settings.DROPOUT_RATE }).apply(x);
  }
  const mainOut = tf.layers.dense({
    units: settings.MAIN_MAX,
    activation: 'sigmoid',
    name: 'main_numbers_output'
  }).apply(x);

  let model, outputs;
  if (hasExtraBall) {
    const extraOut = tf.layers.dense({
      units: settings.EXTRA_MAX,
      activation: 'sigmoid',
      name: 'extra_output'
    }).apply(x);
    outputs = [mainOut, extraOut];
    model = tf.model({ inputs: input, outputs });
  } else {
    outputs = mainOut;
    model = tf.model({ inputs: input, outputs });
  }

  // 6) compile
  const optimizer = tf.train.adam(settings.LEARNING_RATE);
  const loss      = hasExtraBall
    ? ['binaryCrossentropy','binaryCrossentropy']
    : 'binaryCrossentropy';
  model.compile({ optimizer, loss, metrics: ['accuracy'] });

  // 7) prepare yTrain (no sampleWeight support in this tfjs build)
  let yTrain;
  if (hasExtraBall) {
    yTrain = {
      main_numbers_output: ysMainTensor,
      extra_output: ysExtraTensor
    };
  } else {
    yTrain = ysMainTensor;
  }

  // 8) fit model (recency-weighted)
  // sampleWeightTensor is a per-sample exponential decay weight (newest samples weigh more).
  const fitArgs = {
    epochs:          settings.EPOCHS,
    batchSize:       settings.BATCH_SIZE,
    shuffle:         false,
    validationSplit: 0.2,
    callbacks:       { onEpochEnd: onEpochEndCallback }
  };

          // PATCH: sampleWeight not supported in this TFJS build; disable to avoid runtime error.
          // Recency is still used in backtesting via SKAI blend + skip features; full per-sample weighting requires a TFJS build that supports sampleWeight.
          // fitArgs.sampleWeight = hasExtraBall
          //   ? [sampleWeightTensor, sampleWeightTensor]
          //   : sampleWeightTensor;

  await model.fit(xsTensor, yTrain, fitArgs);


  return model;
}


async function runBacktesting(sortedDrawsAsc, settings) {
  const results      = [];
  const N            = sortedDrawsAsc.length;

  // SKAI proper scoring aggregates (lower is better for Brier/LogLoss)
  let totalBrierMain = 0;
  let totalLogLossMain = 0;
  let totalExpectedMassInPicksMain = 0;

  let totalBrierExtra = 0;
  let totalLogLossExtra = 0;
  let totalExpectedMassInPicksExtra = 0;  const numBacktests = parseInt(document.getElementById('numDrawsBacktest').value) || 3;
  const backtestIndices = [];
  for (let i = N - numBacktests; i < N; i++) if (i >= 1) backtestIndices.push(i);

  // progress tracking
  const totalSteps = backtestIndices.length * settings.EPOCHS;
  let completed    = 0;
  function updateBacktestProgress() {
    completed++;
    const pct = Math.round((completed/totalSteps)*100);
    backtestProgressBar.style.width   = pct + '%';
    backtestProgressBar.textContent   = pct + '%';
    progressMessage.innerText         = `System Status: Backtesting in progress... (${pct}%)`;
  }

  for (let idx of backtestIndices) {
    const nums       = sortedDrawsAsc[idx].numbers;
    const actualMain = nums.slice(0, settings.PICK_SIZE);
    const actualExtra= settings.HAS_EXTRA
      ? nums.slice(settings.PICK_SIZE, settings.PICK_SIZE + settings.EXTRA_COUNT)
      : [];

    // train & predict
    const trainingDraws = sortedDrawsAsc.slice(0, idx);
    const model         = await trainModelForBacktest(trainingDraws, settings, updateBacktestProgress);

    // prepare last input (normalized numbers + Skip features)
    const drawsNumbersForBT   = trainingDraws.map(d => d.numbers);
    const skipFeatureSeriesBT = computeSkipFeatureSeries(drawsNumbersForBT, settings.PICK_SIZE, settings.MAIN_MAX);
    const lastIndex           = trainingDraws.length - 1;

    const lastBaseNorm = drawsNumbersForBT[lastIndex].map((v,i)=>
      i < settings.PICK_SIZE
        ? v / settings.MAIN_MAX
        : (settings.HAS_EXTRA ? v / settings.EXTRA_MAX : v)
    );
    const lastSkipFeatures = skipFeatureSeriesBT[lastIndex];
    const lastInputVec     = lastBaseNorm.concat(lastSkipFeatures);

    const pred = model.predict(tf.tensor2d([ lastInputVec ]));

    const mainArr  = settings.HAS_EXTRA ? pred[0].dataSync() : pred.dataSync();
    const extraArr = settings.HAS_EXTRA ? pred[1].dataSync() : [];

    // Compute Skip scores for this specific backtest window.
    // trainingDraws is ASC (oldest ? newest), so we reverse to get DESC for computeSkipScores().
    const skipScoresForBacktest = computeSkipScores(
      [...trainingDraws].reverse(),
      settings.PICK_SIZE,
      settings.MAIN_MAX
    );

    // Build full blended mass for proper scoring (main)
    const actualMainSet = new Set(actualMain);

    const aiRawMain = Array.from(mainArr).map(v => {
      const p = (typeof v === 'number' && isFinite(v)) ? v : 0;
      return Math.min(1 - SKAI_EPS, Math.max(SKAI_EPS, p));
    });
    const aiNormMain = normalizePositive(aiRawMain);

    const skipArrMain = Array.isArray(skipScoresForBacktest)
      ? skipScoresForBacktest
      : new Array(aiNormMain.length).fill(0);

   // Mode-aware skip expert + adaptive Mixed ? (agreement-based)
    const modeKeyBT = getSelectedSkaiMode();

    const skipBetaBT = getSkaiSkipBeta(modeKeyBT);
    const skipProbMain = buildSkipExpertProbs(skipArrMain, skipBetaBT);

    const lambdaBT = getSkaiLambda(modeKeyBT, aiNormMain, skipProbMain);

    // PATCH 7B-3B: backtest readout (shows the ? being used for this run)
    var tBT = (typeof skaiGetStoredTemp === 'function') ? skaiGetStoredTemp(modeKeyBT) : 1.0;
    skaiUpdateBlendReadout(modeKeyBT, lambdaBT, skipBetaBT, tBT);

    const probMassMainNorm = logOpinionPool(aiNormMain, skipProbMain, lambdaBT);

    // Deterministic top-20 ranking for backtest evaluation (no exploration here)
    const mainProbs = probMassMainNorm
      .map((p, i) => {
        const skipScore = (Array.isArray(skipScoresForBacktest) && skipScoresForBacktest[i] != null)
          ? skipScoresForBacktest[i]
          : 0;

        return {
          number:    i + 1,
          prob:      p,             // blended mass (sum-to-1)
          baseProb:  aiNormMain[i],  // normalized AI marginal mass
          skipScore: skipScore
        };
      })
      .sort((a, b) => b.prob - a.prob)
      .slice(0, 20);    // Picks used for evaluation (top pickSize from ranked top-20 list)
    const mainPicks = mainProbs.slice(0, settings.PICK_SIZE).map(o => o.number);

    // Proper scoring updates (main)
    totalBrierMain += skaiBrierScore(probMassMainNorm, actualMainSet, settings.MAIN_MAX);
    totalLogLossMain += skaiLogLoss(probMassMainNorm, actualMainSet, settings.MAIN_MAX);
    totalExpectedMassInPicksMain += skaiExpectedMassInPicks(probMassMainNorm, mainPicks);

    let mainMatch=0;
    const predictedMain = mainProbs.map(x=>{
      if (actualMain.includes(x.number)) { mainMatch++; return `[[span class="match"]]${x.number}[[/span]]`; }
      return x.number;
    });
    // top-extras
    let predictedExtra = [], extraMatch=0;
    if (settings.HAS_EXTRA) {
      const actualExtraSet = new Set(actualExtra);

      // Build full normalized mass for extra
      const aiRawExtra = Array.from(extraArr).map(v => {
        const p = (typeof v === 'number' && isFinite(v)) ? v : 0;
        return Math.min(1 - SKAI_EPS, Math.max(SKAI_EPS, p));
      });
      const probMassExtraNorm = normalizePositive(aiRawExtra);

      const extraProbs = Array.from(extraArr)
        .map((p,i)=>({number:i+1,prob:p}))
        .sort((a,b)=>b.prob-a.prob)
        .slice(0, settings.EXTRA_SUGGESTIONS);

      // Picks used for evaluation (top EXTRA_COUNT)
      const extraPicks = extraProbs.slice(0, settings.EXTRA_COUNT).map(o => o.number);

      // Proper scoring updates (extra)
      totalBrierExtra += skaiBrierScore(probMassExtraNorm, actualExtraSet, settings.EXTRA_MAX);
      totalLogLossExtra += skaiLogLoss(probMassExtraNorm, actualExtraSet, settings.EXTRA_MAX);
      totalExpectedMassInPicksExtra += skaiExpectedMassInPicks(probMassExtraNorm, extraPicks);
      predictedExtra = extraProbs.map(x=>{
        if (actualExtra.includes(x.number)) { extraMatch++; return `[[span class="match"]]${x.number}[[/span]]`; }
        return x.number;
      });
    }

    results.push({
      date:             sortedDrawsAsc[idx].draw_date,
      actualMain:       actualMain.join(', '),
      actualExtra,
      predictedMain:    predictedMain.join(', '),
      predictedExtra,
      mainMatchCount:   mainMatch,
      extraMatchCount:  extraMatch
    });
  }

  // Attach a compact SKAI summary for rendering
  const steps = results.length || 1;
  results.skaiSummary = {
    steps: steps,
    avgBrierMain: (totalBrierMain / steps),
    avgLogLossMain: (totalLogLossMain / steps),
    avgExpectedMassMain: (totalExpectedMassInPicksMain / steps),

    avgBrierExtra: (steps > 0 ? (totalBrierExtra / steps) : 0),
    avgLogLossExtra: (steps > 0 ? (totalLogLossExtra / steps) : 0),
    avgExpectedMassExtra: (steps > 0 ? (totalExpectedMassInPicksExtra / steps) : 0)
  };

  return results;
}
// --- END FIXED BACKTEST FUNCTIONS ---


      
      startButton.addEventListener('click', async function startAnalysis(event) {
       // Scroll the loading container into center view on start
setTimeout(() => {
  const loadingEl = document.getElementById('loading');
  if (loadingEl && typeof loadingEl.scrollIntoView === 'function') {
    loadingEl.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
  }
}, 100); // slight delay to ensure DOM has time to show the element
 
        event.preventDefault();

        // ----------------------------------------------------
        // SKAI Gate (server-side): Guest blocked; Enthusiast 1/day
        // ----------------------------------------------------
        try {
          var tokenName = "<?php echo JSession::getFormToken(); ?>";
          var gateUrl = window.location.href;
          gateUrl = gateUrl.indexOf('?') >= 0 ? (gateUrl + "&le_gate=1") : (gateUrl + "?le_gate=1");

          loadingDiv.style.display = 'block';
          startButton.style.display = 'none';

          var gateRes = await fetch(gateUrl, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
            body: tokenName + "=1",
            credentials: "same-origin"
          });

          var gateJson = null;
          try { gateJson = await gateRes.json(); } catch (e) { gateJson = null; }

          if (!gateJson || gateJson.ok !== true) {
            loadingDiv.style.display = 'none';
            startButton.style.display = 'block';

            var msgEl = document.getElementById('signupModalMsg');
            if (msgEl && gateJson && gateJson.message) {
              msgEl.textContent = gateJson.message;
            }
            showSignUpPopup();
            return;
          }
        } catch (err) {
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          alert("We couldn’t verify access for this run. Please refresh and try again.");
          return;
        }

        // TensorFlow.js and Chart.js are loaded via <script> tags in the head.
        // We now rely on the global `tf` and `Chart` objects.
        const EPOCHS = parseInt(epochsInput.value);
        const BATCH_SIZE = parseInt(batchSizeInput.value);
        const DROPOUT_RATE = parseFloat(dropoutRateInput.value);
        const LEARNING_RATE = parseFloat(learningRateInput.value);
        const ACTIVATION_FUNCTION = activationFunctionInput.value;
        const HIDDEN_LAYERS = parseInt(hiddenLayersInput.value);
        const recencyDecay = parseFloat(document.getElementById('recencyDecay').value) || 1;
        document.getElementById('saveRecencyDecay').value = recencyDecay;

        if (isNaN(EPOCHS) || EPOCHS <= 0) {
          alert("Please enter a valid number of epochs.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        if (isNaN(BATCH_SIZE) || BATCH_SIZE <= 0) {
          alert("Please enter a valid batch size.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        if (isNaN(DROPOUT_RATE) || DROPOUT_RATE < 0 || DROPOUT_RATE > 1) {
          alert("Please enter a valid dropout rate between 0 and 1.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        if (isNaN(LEARNING_RATE) || LEARNING_RATE <= 0) {
          alert("Please enter a valid learning rate greater than 0.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        if (!ACTIVATION_FUNCTION) {
          alert("Please select an activation function.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        if (isNaN(HIDDEN_LAYERS) || HIDDEN_LAYERS <= 0) {
          alert("Please enter a valid number of hidden layers.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        epochValue.innerText = EPOCHS;
        batchSizeValue.innerText = BATCH_SIZE;
        dropoutRateValue.innerText = DROPOUT_RATE;
        learningRateValue.innerText = LEARNING_RATE;
        activationFunctionValue.innerText = ACTIVATION_FUNCTION;
        hiddenLayersValue.innerText = HIDDEN_LAYERS;
        recencyDecayValue.innerText = recencyDecay;  
        const latestDrawDate = latestDrawDateInput.value;
        if (!latestDrawDate) {
          alert("Please enter a valid latest draw date.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        latestDrawDateValue.innerText = latestDrawDate;
        const filteredDraws = draws.filter(draw => new Date(draw.draw_date) <= new Date(latestDrawDate));
        // Sort ascending (OLDEST first) so we can build proper next-draw pairs and Skip features
        filteredDraws.sort((a, b) => new Date(a.draw_date) - new Date(b.draw_date));
        if (filteredDraws.length < 2) {
          alert("Not enough data before the selected date. Please choose a different date.");
          loadingDiv.style.display = 'none';
          startButton.style.display = 'block';
          return;
        }
        const latestDrawData = filteredDraws[filteredDraws.length - 1];
        const latestDraw = latestDrawData.numbers;
        const historicalData = filteredDraws.map(draw => draw.numbers);
        // Pre-compute Skip feature series for the full historical sequence
        const skipFeatureSeries = computeSkipFeatureSeries(historicalData, pickSize, mainNumbersMax);
        startTime = Date.now();

        epochStartTime = Date.now();
        let funMessageIndex = 0;
        const funMessageTimer = setInterval(() => {
          funMessageIndex = (funMessageIndex + 1) % funMessages.length;
          funMessageDiv.innerText = funMessages[funMessageIndex];
        }, funMessageInterval);
        countdownDiv.innerHTML = "Estimated time: Calculating...";
        try {
          await tf.setBackend('cpu');
          console.log('TensorFlow.js version:', tf.version.tfjs);
          console.log('Backend:', tf.getBackend());
          progressMessage.innerText = messages[0];
    // normalize and build X/Y (with Skip features)
        const normalizedHistoricalData = normalizeData(historicalData);
        const xs = [];
        const ys_main = [];
        const ys_extra = [];

        // PATCH: Medium recency weighting without sampleWeight (TFJS build limitation)
        // Strategy: replicate newest 25% of training pairs 3× (older 75% stay 1×)
        const totalPairs   = historicalData.length - 1;
        const recentStart  = Math.floor(totalPairs * 0.75); // newest 25%

        for (let i = 0; i < totalPairs; i++) {
          const baseInput    = normalizedHistoricalData[i];
          const skipFeatures = skipFeatureSeries[i];
          const inputVector  = baseInput.concat(skipFeatures);

          const nextDraw = historicalData[i + 1];

          // Y: main multi-hot
          const mainNumbers = nextDraw.slice(0, pickSize);
          const mainNumbersVector = new Array(mainNumbersMax).fill(0);
          mainNumbers.forEach(num => {
            if (num >= 1 && num <= mainNumbersMax) {
              mainNumbersVector[num - 1] = 1;
            }
          });

          // Y: extra one-hot (if present)
          let extraVector = null;
          if (hasExtraBall) {
            const extraNumber = nextDraw[pickSize];
            extraVector = new Array(extraBallMax).fill(0);
            if (extraNumber >= 1 && extraNumber <= extraBallMax) {
              extraVector[extraNumber - 1] = 1;
            }
          }

          // Replication factor (Medium recency)
          const reps = (i >= recentStart) ? 3 : 1;

          for (let r = 0; r < reps; r++) {
            xs.push(inputVector);
            ys_main.push(mainNumbersVector);
            if (hasExtraBall) {
              ys_extra.push(extraVector);
            }
          }
        }

        // PATCH: sampleWeight disabled (not supported in this TFJS build)
        // const sampleWeightTensor = ...


// -- tensors --
        const xsTensor     = tf.tensor2d(xs);
        const ysMainTensor = tf.tensor2d(ys_main);

          let ysExtraTensor;
          if (hasExtraBall) {
            ysExtraTensor = tf.tensor2d(ys_extra);
          }
          const inputShape = xs[0].length;
          const input = tf.input({ shape: [inputShape] });
          let x = tf.layers.dense({ units: 128, activation: ACTIVATION_FUNCTION }).apply(input);
          x = tf.layers.dropout({ rate: DROPOUT_RATE }).apply(x);
          for (let i = 0; i < HIDDEN_LAYERS; i++) {
            x = tf.layers.dense({ units: 64, activation: ACTIVATION_FUNCTION }).apply(x);
            x = tf.layers.dropout({ rate: DROPOUT_RATE }).apply(x);
          }
          const mainNumbersOutput = tf.layers.dense({ units: mainNumbersMax, activation: 'sigmoid', name: 'main_numbers_output' }).apply(x);
          let outputs, model;
          if (hasExtraBall) {
            const extraOutput = tf.layers.dense({ units: extraBallMax, activation: 'sigmoid', name: 'extra_output' }).apply(x);
            outputs = [mainNumbersOutput, extraOutput];
            model = tf.model({ inputs: input, outputs: outputs });
          } else {
            outputs = mainNumbersOutput;
            model = tf.model({ inputs: input, outputs: outputs });
          }
          const optimizer = tf.train.adam(LEARNING_RATE);
          let loss, metrics;
          if (hasExtraBall) {
            loss = ['binaryCrossentropy', 'binaryCrossentropy'];
            metrics = ['accuracy'];
          } else {
            loss = 'binaryCrossentropy';
            metrics = ['accuracy'];
          }
          model.compile({
            optimizer: optimizer,
            loss: loss,
            metrics: metrics
          });
          let yTrain;
          if (hasExtraBall) {
            yTrain = {
              main_numbers_output: ysMainTensor,
              extra_output: ysExtraTensor
            };
          } else {
            yTrain = ysMainTensor;
          }
		const fitArgs = {
            epochs: EPOCHS,
            batchSize: BATCH_SIZE,
            shuffle: false,
            validationSplit: 0.2,
            // PATCH: sampleWeight disabled (not supported in this TFJS build)
            // Recency weighting is approximated via training-pair replication (newest 25% repeated 3×).
            callbacks: {
              onEpochBegin: (epoch, logs) => {
                epochStartTime = Date.now();
                progressMessage.innerText = messages[3];
              },
              onEpochEnd: (epoch, logs) => {
                let epochEndTime = Date.now();
                let epochDuration = (epochEndTime - epochStartTime) / 1000;
                if (epoch === 0) {
                  smoothedTimePerEpoch = epochDuration;
                } else {
                  smoothedTimePerEpoch = (smoothingFactor * epochDuration) + ((1 - smoothingFactor) * smoothedTimePerEpoch);
                }
                let epochsRemaining = EPOCHS - (epoch + 1);
                let estimatedRemainingTime = epochsRemaining * smoothedTimePerEpoch;
                if (estimatedRemainingTime > 0) {
                  let minutes = Math.floor(estimatedRemainingTime / 60);
                  let seconds = Math.floor(estimatedRemainingTime % 60);
                  countdownDiv.innerHTML = `Estimated time left: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                  countdownDiv.innerHTML = "Main analysis completed! Now running backtesting...";
                }
                let percentage = Math.round(((epoch + 1) / EPOCHS) * 100);
                progressBar.style.width = percentage + '%';
                progressBar.textContent = percentage + '%';
                let msgIndex = Math.floor((percentage / 100) * messages.length);
                if (msgIndex >= messages.length) {
                  msgIndex = messages.length - 1;
                }
                progressMessage.innerText = messages[msgIndex];
              }
            }
          };

          // PATCH: training must run before predict; otherwise results are random + instant
          progressMessage.innerText = messages[3];
          await model.fit(xsTensor, yTrain, fitArgs);

          progressMessage.innerText = messages[6];

          // Build prediction input: normalized latest draw + its Skip feature vector
          const latestIndex          = historicalData.length - 1;
          const normalizedLatestDraw = normalizeData([latestDraw])[0];
          const latestSkipFeatures   = skipFeatureSeries[latestIndex];
          const latestInputVector    = normalizedLatestDraw.concat(latestSkipFeatures);

          // Use the latest Skip feature vector as our per-number Skip scores for bias
          const skipScores = latestSkipFeatures;

          const prediction = model.predict(tf.tensor2d([latestInputVector]));
          let mainNumbersPrediction, extraPrediction;
          if (hasExtraBall) {
            mainNumbersPrediction = prediction[0].dataSync();
            extraPrediction = prediction[1].dataSync();
          } else {
            mainNumbersPrediction = prediction.dataSync();
          }
          // Apply mathematically coherent SKAI blend:
          // 1) normalize AI marginals into a mass function
          // 2) convert skipScores into a skip-expert distribution
          // 3) combine via log-opinion pool (geometric mixture)
          const modeKey = getSelectedSkaiMode();

          // 1) AI marginals ? normalized mass
          const aiRaw = Array.from(mainNumbersPrediction).map(v => {
            const p = (typeof v === 'number' && isFinite(v)) ? v : 0;
            return Math.min(1 - SKAI_EPS, Math.max(SKAI_EPS, p));
          });
          const aiNorm = normalizePositive(aiRaw);

          // 2) Skip scores ? skip-expert distribution
          const skipArr = Array.isArray(skipScores)
            ? skipScores
            : new Array(aiNorm.length).fill(0);

          const skipBetaLocal = getSkaiSkipBeta(modeKey);
          const skipProbLocal = buildSkipExpertProbs(skipArr, skipBetaLocal);

          // 3) Blend weight ? (adaptive in Mixed)
          const lambdaLocal = getSkaiLambda(modeKey, aiNorm, skipProbLocal);

          // Live blend readout (AI ? vs Skip 1-?, plus ß and T)
          var tLive = (typeof skaiGetStoredTemp === 'function') ? skaiGetStoredTemp(modeKey) : 1.0;
          skaiUpdateBlendReadout(modeKey, lambdaLocal, skipBetaLocal, tLive);

          const finalProbNorm = logOpinionPool(aiNorm, skipProbLocal, lambdaLocal);

          // PATCH: removed duplicate (older) SKAI blend block to prevent redeclarations

          // PATCH 7B-3A: live readout with actual ? (adaptive in Mixed)
          // PATCH: lambdaLocal is the live ? from the SKAI blend block above
          var tLive = (typeof skaiGetStoredTemp === 'function') ? skaiGetStoredTemp(modeKey) : 1.0;
          skaiUpdateBlendReadout(modeKey, lambdaLocal, skipBetaLocal, tLive);

          // PATCH: removed duplicate finalProbNorm declaration; reuse the earlier finalProbNorm
          const mainNumbersProbabilities = finalProbNorm.map((p, i) => {
            const number    = i + 1;
            const skipScore = (Array.isArray(skipScores) && skipScores[i] != null) ? skipScores[i] : 0;

            return {
              number,
              probability:      p,          // math-correct blended mass (sum-to-1)
              baseProbability:  aiNorm[i],   // normalized AI marginal mass
              skipScore:        skipScore
            };
          });
          mainNumbersProbabilities.sort((a, b) => b.probability - a.probability);
          // Final selection: exploit + controlled exploration (Explorative/Mixed), strict top-k otherwise
          const pickedNumbers = skaiSelectPicksFromMass(finalProbNorm, pickSize, modeKey);

          // Map pickedNumbers back to objects (for display wiring that expects {number,...})
          const pickedSet = new Set(pickedNumbers);
          const predictedMainNumbers = mainNumbersProbabilities
            .filter(item => pickedSet.has(item.number))
            .sort((a, b) => a.number - b.number);
          let numbersHTML = '';
      
          // Add main numbers
          predictedMainNumbers.slice(0, pickSize).forEach((item) => {
              numbersHTML += `[[span class="number-ball"]]${item.number}[[/span]]\n`;
          });
      
          // Add extra ball if available
          if (hasExtraBall && predictedMainNumbers.length > pickSize) {
              let extraBall = predictedMainNumbers[pickSize]; // The extra ball
              numbersHTML += `[[span class="number-ball powerball"]]${extraBall.number}[[/span]]\n`;
          }
      
          predictedNumbersDiv.style.display = "none";
      
          let breakdownHTML = `
            [[h3]]Top 20 Main Numbers Breakdown[[/h3]]
            [[table]]
              [[thead]]
                [[tr]]
                  [[th]]Number[[/th]]
                  [[th]]Probability (%)[[/th]]
                [[/tr]]
              [[/thead]]
              [[tbody]]
          `;
          mainNumbersProbabilities.slice(0, 20).forEach(item => {
            const probabilityPercentage = (item.probability * 100).toFixed(2);
            breakdownHTML += `
              [[tr]]
                [[td]]${item.number}[[/td]]
                [[td]]${probabilityPercentage}%[[/td]]
              [[/tr]]
            `;
          });
          breakdownHTML += `
              [[/tbody]]
            [[/table]]
          `;
          if (hasExtraBall) {
            const extraProbabilities = Array.from(extraPrediction)
              .map((prob, index) => ({ number: index + 1, probability: prob }));
            extraProbabilities.sort((a, b) => b.probability - a.probability);
            breakdownHTML += `
              [[h3]]Top 5 Extra Numbers Breakdown[[/h3]]
              [[table]]
                [[thead]]
                  [[tr]]
                    [[th]]Number[[/th]]
                    [[th]]Probability (%)[[/th]]
                  [[/tr]]
                [[/thead]]
                [[tbody]]
            `;
            extraProbabilities.slice(0, 5).forEach(item => {
              const probabilityPercentage = (item.probability * 100).toFixed(2);
              breakdownHTML += `
                [[tr]]
                  [[td]]${item.number}[[/td]]
                  [[td]]${probabilityPercentage}%[[/td]]
                [[/tr]]
              `;
            });
            breakdownHTML += `
                [[/tbody]]
              [[/table]]
            `;
          }
          numberBreakdownTableDiv.innerHTML = breakdownHTML;
          
          progressMessage.innerText = messages[8];
          const predictionDate = new Date();
          const predictionDateString = predictionDate.toLocaleString();
          predictionDateValue.innerText = predictionDateString;
 
   
        
        // (1) capture your PHP lotteryName into JS input
const lotteryName = <?php echo json_encode($lotteryName); ?>;

// (2) update the hidden generated_at if you haven’t already
document.getElementById('saveGeneratedAt').value =
  predictionDateString; // or use your formatDateForDB() if you need YYYY-MM-DD HH:MM:SS

// (3) now push the same timestamp into your label field
document.getElementById('saveLabel').value =
  `${lotteryName} Prediction – ${predictionDateString}`;

        
        
        // — format to YYYY-MM-DD HH:MM:SS for our DB —
function formatDateForDB(d) {
  const p = n => String(n).padStart(2,'0');
  return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())} ` +
         `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`;
}

      // populate hidden field with DB-formatted timestamp
        const now = new Date();
        const dbTimestamp = formatDateForDB(now);
        document.getElementById('saveGeneratedAt').value = dbTimestamp;
        // label can still show human-friendly time
        document.getElementById('saveLabel').value =
          `${lotteryName} Prediction – ${now.toLocaleString()}`;


// Save AI analysis specs to hidden fields
document.getElementById('saveEpochs').value              = EPOCHS;
document.getElementById('saveBatchSize').value           = BATCH_SIZE;
document.getElementById('saveDropoutRate').value         = DROPOUT_RATE;
document.getElementById('saveLearningRate').value        = LEARNING_RATE;
document.getElementById('saveActivationFunction').value  = ACTIVATION_FUNCTION;
document.getElementById('saveHiddenLayers').value        = HIDDEN_LAYERS;

 
           // After generating the predictions, populate the hidden fields in the save form
          // For MAIN numbers, use all predicted main numbers instead of just the first "pickSize".
          const mainPredictionNumbers = mainNumbersProbabilities
  .slice(0, 20)
  .map(item => item.number)
  .join(',');

      
          // For the EXTRA ball predictions, if applicable, compute the entire sorted list
          let extraPredictionNumbers = "";
          if (hasExtraBall) {
            const extraProbabilities = Array.from(extraPrediction).map((prob, index) => ({ number: index + 1, probability: prob }));
            extraProbabilities.sort((a, b) => b.probability - a.probability);
           extraPredictionNumbers = extraProbabilities
  .slice(0, 5)
  .map(item => item.number)
  .join(',');
          }
      
          // Populate the hidden form fields with the entire list of predicted values.
          document.getElementById('saveMainNumbers').value = mainPredictionNumbers;
          document.getElementById('saveExtraBallNumbers').value = extraPredictionNumbers;
      
          // BEGIN BACKTESTING STEP (if user enabled it)
          if (enableBacktestCheckbox.checked) {
            backtestNoticeDiv.style.display = 'block';
            backtestProgressContainer.style.display = 'block';
            countdownDiv.innerHTML = "Running backtesting on previous draws...";
      
            const sortedDrawsAsc = [...filteredDraws].sort((a, b) => new Date(a.draw_date) - new Date(b.draw_date));
 const settings = {
  EPOCHS,
  BATCH_SIZE,
  DROPOUT_RATE,
  LEARNING_RATE,
  ACTIVATION_FUNCTION,
  HIDDEN_LAYERS,

  // new entries so trainModelForBacktest() and runBacktesting() see them:
  RECENCY_DECAY:   recencyDecay,       // from your earlier const
  PICK_SIZE:       pickSize,           // global var you defined above
  MAIN_MAX:        mainNumbersMax,     // global var you defined above
  EXTRA_COUNT:     numExtraBalls,      // global var you defined above
  EXTRA_MAX:       extraBallMax,       // global var you defined above
  HAS_EXTRA:       hasExtraBall,       // global var you defined above
  EXTRA_SUGGESTIONS: topExtraSuggestions
};

const backtestResults = await runBacktesting(sortedDrawsAsc, settings);

            const backtestHTML = renderBacktestResults(backtestResults);
            backtestResultsDiv.innerHTML = backtestHTML;
            backtestResultsDiv.style.display = 'block';
            
            // Update backtesting notice and hide the progress bar now that backtesting is complete
            backtestNoticeDiv.innerHTML = "[[h4]]Backtesting Complete[[/h4]][[p]]Backtesting has finished processing all draws.[[/p]]";
            backtestProgressContainer.style.display = 'none';
      
            // ? Update message to show final completion
            countdownDiv.innerHTML = "Done! Analysis is complete.";
      
          }
          // END BACKTESTING STEP
          setTimeout(() => {
            loadingDiv.style.display = 'none';
            predictionDiv.style.display = 'block';
            numberBreakdownDiv.style.display = 'block';
          }, 1000);
          clearInterval(funMessageTimer);
        } catch (error) {
          console.error('Error during model training or Analysis:', error);
          loadingDiv.innerText = 'An error occurred during model training or Analysis: ' + error.message;
          startButton.style.display = 'block';
        }
      });
    });
  [[/script]]
  <!-- Deferred Chart & TFJS initialization (Block C) -->
[[script defer]]
document.addEventListener('DOMContentLoaded', function () {
  const ctx1 = document.getElementById('coverageChart')?.getContext('2d');
  const ctx2 = document.getElementById('ticketsChart')?.getContext('2d');

  if (!ctx1 || !ctx2 || typeof Chart === 'undefined') {
    console.error("Chart.js not ready or canvas not found.");
    return;
  }

  const rootStyles = getComputedStyle(document.documentElement);
  let primaryBlue = rootStyles.getPropertyValue('--primary-blue').trim();
  if (!primaryBlue) {
    primaryBlue = rootStyles.getPropertyValue('--skai-blue').trim() || '#1C66FF';
  }

  const commonOptions = (label) => ({
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { display: false }
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: label, color: '#333' },
        ticks: {
          color: '#333',
          callback: function (val) {
            if (label.includes('Coverage')) return val + '%';
            if (val >= 1000) return (val / 1000).toFixed(1) + 'k';
            return val;
          }
        },
        grid: { color: '#ccc' }
      },
      x: {
        ticks: { color: '#333' },
        grid: { display: false }
      }
    }
  });

  new Chart(ctx1, {
    type: 'bar',
    data: {
      labels: <?php echo json_encode(array_column($stats, 'count')); ?>,
      datasets: [{
        data: <?php echo json_encode(array_column($stats, 'pct')); ?>,
        backgroundColor: primaryBlue,
        borderRadius: 4
      }]
    },
    options: commonOptions('Coverage %')
  });

  new Chart(ctx2, {
    type: 'bar',
    data: {
      labels: ['Full Wheel', 'Reduced Wheel'],
      datasets: [{
        data: [11628, 28],
        backgroundColor: primaryBlue,
        borderRadius: 4
      }]
    },
    options: commonOptions('Tickets')
  });
});
[[/script]]
[[/body]]
[[/html]]

{/source}
